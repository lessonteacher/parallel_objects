<?xml version="1.0" encoding="utf-8"?>
<nugget name="PRC_OBJECTS">
 <CLAS CLSNAME="ZCX_PRC_EXCESSIVE_DELAY" VERSION="1" LANGU="E" DESCRIPT="The process failed already during execution, check error tra" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_EXCESSIVE_DELAY" REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_BG_BATCH_JOB" VERSION="1" LANGU="E" DESCRIPT="Runs as a Background Job(e.g. a job is submitted internally)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_BG_BATCH_JOB" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_processor definition.
  public section.
    methods:
      constructor
        importing ir_process type ref to zcl_prc_bg_batch_job,
      dispatch
        importing iv_uname type sy-uname default sy-uname
        raising zcx_prc_process_exception zcx_prc_wait_timout_exception.
  protected section.
  private section.
    data: mr_process type ref to zcl_prc_bg_batch_job.
    methods:
      serialize returning value(rv_process) type zprce_data.
endclass.                    &quot;lcl_processor DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_processor IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_processor implementation.
  method constructor.
    mr_process = ir_process.
  endmethod.                    &quot;constructor

  method serialize.
    call transformation id_indent
     source obj = mr_process
     result xml rv_process.
  endmethod.                    &quot;serialize
  method dispatch.
    data: ls_bg type zprcd_bg_batch.

    &quot;... Set the guid
    mr_process-&gt;mv_guid = cl_system_uuid=&gt;create_uuid_x16_static( ).
    convert
      date mr_process-&gt;mr_schedule-&gt;date( )
      time mr_process-&gt;mr_schedule-&gt;time( )
      into time stamp data(lv_start_time) time zone sy-zonlo.

    &quot;... Get the serialized data
    ls_bg-data = serialize( ).
    ls_bg-guid = mr_process-&gt;mv_guid.
    get time stamp field ls_bg-time.
    ls_bg-start_time = lv_start_time.

    &quot;... The program will use this table entry
    modify zprcd_bg_batch from ls_bg.

    &quot;... Commit
    commit work.
  endmethod.                   &quot;dispatch
endclass.                    &quot;lcl_processor IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section
class lcl_processor definition deferred.
class zcl_prc_bg_batch_job definition local friends lcl_processor.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="MR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="MR_SCHEDULE" VERSION="1" LANGU="E" DESCRIPT="Used to add scheduling" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_PRC_JOB_SCHEDULE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="MV_DELAY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="MV_GROUP" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTVALUE="&apos; &apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="MV_GUID" VERSION="1" LANGU="E" DESCRIPT="16 Byte UUID in 16 Bytes (Raw Format)" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SYSUUID_X16" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="CONSTRUCTOR" SCONAME="IR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE"/>
   <parameter CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="CONSTRUCTOR" SCONAME="IV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Seconds, yes as a char e.g. &apos;2&apos; or &apos;0.2&apos; dont ask" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <source>method CONSTRUCTOR.
  mr_runnable = ir_runnable.
  mv_delay = iv_delay.
endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="START" VERSION="1" LANGU="E" DESCRIPT="Start the process" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="START" SCONAME="SCHEDULE" VERSION="1" LANGU="E" DESCRIPT="Used to add scheduling" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_PRC_JOB_SCHEDULE" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="START" SCONAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_BG_BATCH_JOB" CMPNAME="START" SCONAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="2 "/>
   <source>method START.
  data: lr_processor type ref to lcl_processor.

  mr_schedule = schedule.

  create object lr_processor
    exporting
      ir_process = me.

  lr_processor-&gt;dispatch( ).
endmethod.                    &quot;START</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" VERSION="1" LANGU="E" DESCRIPT="PRC Completion Monitor" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_processor definition.
  public section.
    methods:
      constructor
        importing
          ir_callable type ref to zif_prc_callable
          iv_delay type string optional
          iv_timeout type i optional,
      dispatch
        raising zcx_prc_process_exception zcx_prc_wait_timout_exception.
  protected section.
  private section.
    data: mr_callable type ref to zif_prc_callable,
          mv_delay type string,
          mv_timeout type i.
    methods:
      serialize returning value(rv_callable) type zprce_data.
    methods:
      initialize_group returning value(rv_group) type rzlli_apcl.
    methods:
      get_wp_id returning value(rv_wpid) type char8.
endclass.                    &quot;lcl_processor DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_processor IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_processor implementation.
  method constructor.
    mr_callable = ir_callable.
    mv_delay = iv_delay.
    mv_timeout = iv_timeout.
  endmethod.                    &quot;constructor

  method serialize.
    call transformation id_indent
     source obj = mr_callable
     result xml rv_callable.
  endmethod.                    &quot;serialize
  method dispatch.
    data: lv_group type rzlli_apcl value &apos; &apos;,
          lv_data type zprce_data,
          lv_time type t.

    get time field lv_time.
    do. &quot;... Timeout checked at end

      try.
          if zcl_prc_future_executor=&gt;get_wp_avail( ) ne 0.

            &quot;... Set the process ID
            mr_callable-&gt;mv_cpid = zcl_prc_future_executor=&gt;register_pid( ).
            mr_callable-&gt;mv_guid = cl_system_uuid=&gt;create_uuid_x16_static( ).
            mr_callable-&gt;mv_wpid = get_wp_id( ).

            &quot;... Get the serialized data
            lv_data = serialize( ).

            call function &apos;Z_PRC_RUN_FUTURE_TASK&apos; starting new task mr_callable-&gt;mv_cpid
              destination &apos;NONE&apos;
              exporting
                iv_callable           = lv_data
                iv_delay              = mv_delay
              exceptions
                system_failure        = 1
                communication_failure = 2
                resource_failure      = 3.

            case sy-subrc.
              when 0.
                exit. &quot;... Exit the do loop to complete the method
              when 3.
                &quot;... Do nothing because we are waiting
              when others.
                &quot;... Explode in other cases
                raise exception type zcx_prc_system_failure.
            endcase.
          endif.
        catch zcx_prc_no_processes_avail.
          &quot;... No process available, occurs under very high load
          &quot;... Let the retry occur
      endtry.
      get time. &quot;... Init the system time to be sure
      if ( ( sy-uzeit - lv_time ) mod 86400 ) gt mv_timeout.
        &quot;... Wait time is over
        raise exception type zcx_prc_wait_timout_exception.
      endif.
    enddo.
  endmethod.                    &quot;dispatch
  method initialize_group.
    data: lv_available type i,
          lv_time type t,
          lv_initial type abap_bool value abap_true,
          lv_max type i.
    get time field lv_time.
    do. &quot;... Timeout checked at end
      &quot;... IF unsure do intialisation
      if lv_initial eq abap_true.
        &quot;... Prepare for launch, we need the number of available processes
        call function &apos;SPBT_INITIALIZE&apos;
          exporting
            group_name                     = rv_group &quot;... name of group
          importing
            max_pbt_wps                    = lv_max &quot;... number of dialog processes avail
            free_pbt_wps                   = lv_available &quot;... number available
          exceptions
            invalid_group_name             = 1 &quot;... Incorrect group name; RFC group not defined.
*                                              &quot;... See transaction RZ12
            internal_error                 = 2 &quot;... Server error
            pbt_env_already_initialized    = 3 &quot;... Apparently this FM can only be called once
            currently_no_resources_avail   = 4 &quot;... No processes available / workload too high
            no_pbt_resources_found         = 5 &quot;... No servers in workgrp with 2 or more processes defined
            cant_init_different_pbt_groups = 6 &quot;... Another grp is already initialised
            others                         = 7. &quot;... Who knows?
      else.
        &quot;... We are certain initialisation is done lets check resources
        call function &apos;SPBT_GET_CURR_RESOURCE_INFO&apos;
          importing
            max_pbt_wps                 = lv_max
            free_pbt_wps                = lv_available
          exceptions
            internal_error              = 1
            pbt_env_not_initialized_yet = 2
            others                      = 3. &quot;... Thanks SAP for making 3 other! thats really not
*                                                 very helpful for my case statement
      endif.
      case sy-subrc.
        when 3. &quot;... Either initial failed or getting resources failed
          if lv_initial eq abap_true.
            lv_initial = abap_false.
            mv_timeout = mv_timeout + 1. &quot;... A second was wasted so add it back on
            continue.
          else.
            &quot;... Resource grab failed
            raise exception type zcx_prc_process_exception.
          endif.
        when 4 or 0.
          &quot;... Not enough available processes
          if lv_available eq 0 or zcl_prc_future_executor=&gt;get_wp_avail( ) eq 0.
            &quot;... Do nothing we will continue the loop
          else.
            &quot;... Theres at least 1 process free so lets exit the do loop and move on
            exit.
          endif.
        when others.
          raise exception type zcx_prc_process_exception.
      endcase.

      get time. &quot;... Init the system time to be sure
      if ( ( sy-uzeit - lv_time ) mod 86400 ) gt mv_timeout.
        &quot;... Wait time is over
        raise exception type zcx_prc_wait_timout_exception.
      endif.
    enddo.
  endmethod.
  method get_wp_id.

    &quot;...get the originating work process ID
    call function &apos;TH_GET_OWN_WP_NO&apos;
     importing
       wp_pid = rv_wpid.

  endmethod.                  &quot;get work process id
endclass.                    &quot;lcl_processor IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section
class lcl_processor definition deferred.
class ZCL_prc_future_executor definition local friends lcl_processor.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" TYPEGROUP="ZCL_PRC_EXECUTOR_ACCESS" VERSION="1" TPUTYPE="1" EXPLICIT="X" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="MV_TIMEOUT" VERSION="1" LANGU="E" DESCRIPT="Timeout in seconds" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTVALUE="299" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="ATTACH_WP" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="ATTACH_WP" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method ATTACH_WP.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    lr_executor-&gt;attach_wp( iv_pid ).
    lr_area-&gt;detach_commit( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="CONSTRUCTOR" SCONAME="IV_MAXPROCESSES" VERSION="1" LANGU="E" DESCRIPT="Maximum work processes to use" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="CONSTRUCTOR" SCONAME="IV_TIMEOUT" VERSION="1" LANGU="E" DESCRIPT="Timeout in seconds when attempting to access shared memory" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="43200"/>
   <source>method constructor.
    mv_timeout = iv_timeout.

    if iv_maxprocesses is not initial.
      max_work_processes( iv_maxprocesses ).
    else.
      max_work_processes( zcl_prc_wp_manager=&gt;get_max_work_processes( ) ).
    endif.
  endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="DEREGISTER_PID" VERSION="1" LANGU="E" DESCRIPT="Public for FM module access ONLY" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="DEREGISTER_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method DEREGISTER_PID.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    lr_executor-&gt;deregister_pid( iv_pid ).
    lr_area-&gt;detach_commit( ).
  endmethod.                    &quot;DEREGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="GARBAGE_COLLECT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="GARBAGE_COLLECT" SCONAME="IV_BYPASS_LONGCHK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
   <source>method GARBAGE_COLLECT.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    lr_executor-&gt;garbage_collect( iv_bypass_longchk ).
    lr_area-&gt;detach_commit( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="GET_WP_AVAIL" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="GET_WP_AVAIL" SCONAME="RV_WP_AVAIL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_WP_AVAIL.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          rv_cleaned type abap_bool,
          lv_time type t.

    &quot;... Do any GC first
    garbage_collect( ).

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_read( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_inconsistent. &quot;... When inconsistent all we need to do is reset this
          zcl_prc_executor_area=&gt;free_area( ). &quot;... If this fails we have a real problem
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    rv_wp_avail = lr_executor-&gt;get_wp_avail( ).
    lr_area-&gt;detach( ).

    case rv_wp_avail.
      when -1. &quot;... Not initialised
        &quot;... Initialise the work processes to default, can return that value here
        rv_wp_avail = zcl_prc_wp_manager=&gt;get_max_work_processes( ).
        max_work_processes( rv_wp_avail ).
    endcase.
  endmethod.                    &quot;GET_WP_AVAIL</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="HAS_PROCESSES" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="HAS_PROCESSES" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method HAS_PROCESSES.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
            lr_exc type ref to cx_shm_attach_error,
            lv_time type t.

    &quot;... Do any GC first(probably not used for completion?)
    garbage_collect( abap_true ).

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_read( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    rv_result = lr_executor-&gt;has_processes( ).
    lr_area-&gt;detach( ).

  endmethod.                    &quot;HAS_PROCESSES</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="MAX_WORK_PROCESSES" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="MAX_WORK_PROCESSES" SCONAME="IV_NUM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method MAX_WORK_PROCESSES.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_inconsistent. &quot;... When inconsistent all we need to do is reset this
          zcl_prc_executor_area=&gt;free_area( ). &quot;... If this fails we have a real problem
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    lr_executor-&gt;number_of_processes( iv_num ).
    lr_area-&gt;detach_commit( ).
  endmethod.                    &quot;MAX_WORK_PROCESSES</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="PID_EXISTS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="PID_EXISTS" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="PID_EXISTS" SCONAME="RV_EXISTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method PID_EXISTS.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_read( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    rv_exists = lr_executor-&gt;pid_exists( iv_pid ).
    lr_area-&gt;detach( ).
  endmethod.                    &quot;PID_EXISTS</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="REGISTER_PID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="REGISTER_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <exception CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="REGISTER_PID" SCONAME="ZCX_PRC_NO_PROCESSES_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Raised when no proceses available for user" MTDTYPE="0" EDITORDER="1 "/>
   <source>method REGISTER_PID.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    rv_pid = lr_executor-&gt;register_pid( ).
    lr_area-&gt;detach_commit( ).
  endmethod.                    &quot;REGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SET_RESULT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SET_RESULT" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SET_RESULT" SCONAME="IV_GUID" VERSION="1" LANGU="E" DESCRIPT="16 Byte UUID in 16 Bytes (Raw Format)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_X16"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SET_RESULT" SCONAME="IR_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SET_RESULT" SCONAME="IV_WPID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <exception CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SET_RESULT" SCONAME="ZCX_PRC_NON_SERIALIZABLE" VERSION="1" LANGU="E" DESCRIPT="A Result object ref was used that cant be serialized" MTDTYPE="0" EDITORDER="1 "/>
   <source>method SET_RESULT.
    data: lr_area type ref to zcl_prc_executor_area,
      lr_executor type ref to zcl_prc_executor_access,
      lr_exc type ref to cx_shm_attach_error,
      lv_data type zprce_data,
      lv_time type t.

    &quot;... First thing to do is try to serialize the input
    try.
        lv_data = zcl_prc_serialization_util=&gt;serialize_result( ir_result ).
      catch zcx_prc_non_serializable.
        raise exception type zcx_prc_non_serializable.
    endtry.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    lr_executor-&gt;set_result( iv_pid    = iv_pid
                             iv_guid   = iv_guid
                             iv_wpid   = iv_wpid
                             iv_result = lv_data ).
    lr_area-&gt;detach_commit( ).
  endmethod.                    &quot;SET_RESULT</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SUBMIT" VERSION="1" LANGU="E" DESCRIPT="Submit a Callable Completion Process" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SUBMIT" SCONAME="IR_CALLABLE" VERSION="1" LANGU="E" DESCRIPT="Callback interface for definition of callback" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_PRC_CALLABLE"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SUBMIT" SCONAME="IV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Seconds, yes as a char e.g. &apos;2&apos; or &apos;0.2&apos; dont ask" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_EXECUTOR" CMPNAME="SUBMIT" SCONAME="RR_PROCESS" VERSION="1" LANGU="E" DESCRIPT="Process" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_FUTURE_TASK"/>
   <source>method submit.
    data: lr_processor type ref to lcl_processor,
          lv_pid type char8.
    data: lv_p type p decimals 2.
    lv_p = iv_delay.
    if lv_p gt 45.
      raise exception type zcx_prc_excessive_delay.
    endif.

    create object lr_processor
      exporting
        ir_callable = ir_callable
        iv_delay    = iv_delay
        iv_timeout  = mv_timeout.

    lr_processor-&gt;dispatch( ).

    create object rr_process
      exporting
        ir_callable = ir_callable.
  endmethod.                    &quot;submit</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_MANAGED_TASK" VERSION="1" LANGU="E" DESCRIPT="Runs as new task with shared memory management" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_MANAGED_TASK" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_processor definition.
  public section.
    methods:
      constructor importing ir_process type ref to zcl_prc_managed_task,
      dispatch raising zcx_prc_process_exception zcx_prc_wait_timout_exception.
  protected section.
  private section.
    data: mr_process type ref to zcl_prc_managed_task.
    methods:
      serialize returning value(rv_process) type zprce_data.
    methods:
      initialize_group returning value(rv_group) type rzlli_apcl.
endclass.                    &quot;lcl_processor DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_processor IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_processor implementation.
  method constructor.
    mr_process = ir_process.
  endmethod.                    &quot;constructor

  method serialize.
    call transformation id_indent
     source obj = mr_process
     result xml rv_process.
  endmethod.                    &quot;serialize
  method dispatch.
    data: lv_data type zprce_data,
          lv_time type t,
          lv_group type rzlli_apcl.

    get time field lv_time.
    do. &quot;... Timeout checked at end
      try.
          if zcl_prc_monitor=&gt;get_wp_avail( ) ne 0.

            &quot;... Set the process ID
            mr_process-&gt;set_pid( zcl_prc_monitor=&gt;register_pid( ) ).

            &quot;... Get the serialized data
            lv_data = serialize( ).

            call function &apos;Z_PRC_RUN_MANAGED_TASK&apos; starting new task mr_process-&gt;mv_pid
              destination &apos;NONE&apos;
              exporting
                iv_process            = lv_data
                iv_delay              = mr_process-&gt;mv_delay
              exceptions
                system_failure        = 1
                communication_failure = 2
                resource_failure      = 3.

            case sy-subrc.
              when 0.
                exit. &quot;... Exit the do loop to complete the method
              when 3.
                &quot;... Do nothing because we are waiting
              when others.
                &quot;... Explode in other cases
                raise exception type zcx_prc_system_failure.
            endcase.
          endif.
        catch zcx_prc_no_processes_avail.
          &quot;... No process available, occurs under very high load
          &quot;... Let the retry occur
      endtry.
      get time. &quot;... Init the system time to be sure
      if ( ( sy-uzeit - lv_time ) mod 86400 ) gt mr_process-&gt;mv_timeout.
        &quot;... Wait time is over
        raise exception type zcx_prc_wait_timout_exception.
      endif.
    enddo.
  endmethod.                   &quot;dispatch
  method initialize_group.
    data: lv_available type i,
          lv_time type t,
          lv_initial type abap_bool value abap_true,
          lv_max type i.
    get time field lv_time.
    do. &quot;... Timeout checked at end
      &quot;... IF unsure do intialisation
      if lv_initial eq abap_true.
        &quot;... Prepare for launch, we need the number of available processes
        call function &apos;SPBT_INITIALIZE&apos;
          exporting
            group_name                     = rv_group &quot;... name of group
          importing
            max_pbt_wps                    = lv_max &quot;... number of dialog processes avail
            free_pbt_wps                   = lv_available &quot;... number available
          exceptions
            invalid_group_name             = 1 &quot;... Incorrect group name; RFC group not defined.
            &quot;... See transaction RZ12
            internal_error                 = 2 &quot;... Server error
            pbt_env_already_initialized    = 3 &quot;... Apparently this FM can only be called once
            currently_no_resources_avail   = 4 &quot;... No processes available / workload too high
            no_pbt_resources_found         = 5 &quot;... No servers in workgrp with 2 or more processes defined
            cant_init_different_pbt_groups = 6 &quot;... Another grp is already initialised
            others                         = 7. &quot;... Who knows?
      else.
        &quot;... We are certain initialisation is done lets check resources
        call function &apos;SPBT_GET_CURR_RESOURCE_INFO&apos;
          importing
            max_pbt_wps                 = lv_max
            free_pbt_wps                = lv_available
          exceptions
            internal_error              = 1
            pbt_env_not_initialized_yet = 2
            others                      = 3. &quot;... Thanks SAP for making 3 other! thats really not
*                                                 very helpful for my case statement
      endif.
      case sy-subrc.
        when 3. &quot;... Either initial failed or getting resources failed
          if lv_initial eq abap_true.
            lv_initial = abap_false.
            mr_process-&gt;mv_timeout = mr_process-&gt;mv_timeout + 1. &quot;... A second was wasted so add it back on
            continue.
          else.
            &quot;... Resource grab failed
            raise exception type zcx_prc_process_exception.
          endif.
        when 4 or 0.
          &quot;... Not enough available processes
          if lv_available eq 0 or zcl_prc_monitor=&gt;get_wp_avail( ) eq 0.
            &quot;... Do nothing we will continue the loop
          else.
            &quot;... Theres at least 1 process free so lets exit the do loop and move on
            exit.
          endif.
        when others.
          raise exception type zcx_prc_process_exception.
      endcase.

      get time. &quot;... Init the system time to be sure
      if ( ( sy-uzeit - lv_time ) mod 86400 ) gt mr_process-&gt;mv_timeout.
        &quot;... Wait time is over
        raise exception type zcx_prc_wait_timout_exception.
      endif.
    enddo.
  endmethod.
endclass.                    &quot;lcl_processor IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section
class lcl_processor definition deferred.
class ZCL_PRC_MANAGED_TASK definition local friends lcl_processor.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="MR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="MV_DELAY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="MV_PID" VERSION="1" LANGU="E" DESCRIPT="Process ID" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR8" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="MV_TIMEOUT" VERSION="1" LANGU="E" DESCRIPT="Timeout in seconds" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTVALUE="299" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE"/>
   <parameter CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_DELAY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <source>method CONSTRUCTOR.
  data: lv_p type p decimals 2.
  lv_p = iv_delay.
  if lv_p gt 45.
    raise exception type zcx_prc_excessive_delay.
  endif.
  mr_runnable = ir_runnable.
  mv_delay = iv_delay.
endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="GET_PID" VERSION="1" LANGU="E" DESCRIPT="Get the process ID" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="GET_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method GET_PID.
    rv_pid = mv_pid.
  endmethod.                    &quot;GET_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="SET_PID" VERSION="1" LANGU="E" DESCRIPT="Set the process ID (used in FM now)" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="SET_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method SET_PID.
  mv_pid = iv_pid.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="START" VERSION="1" LANGU="E" DESCRIPT="Start the process" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="START" SCONAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_MANAGED_TASK" CMPNAME="START" SCONAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="2 "/>
   <source>method START.
    data: lr_processor type ref to lcl_processor.

    create object lr_processor
      exporting
        ir_process = me.

    lr_processor-&gt;dispatch( ).
  endmethod.                    &quot;START</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_ISOLATED_TASK" VERSION="1" LANGU="E" DESCRIPT="Runs as an isolated Background Task(its still a DIA WP)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_ISOLATED_TASK" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_processor definition.
  public section.
    methods:
      constructor importing ir_process type ref to zcl_prc_isolated_task,
      dispatch raising zcx_prc_process_exception zcx_prc_wait_timout_exception.
  protected section.
  private section.
    data: mr_process type ref to zcl_prc_isolated_task.
    methods:
      serialize returning value(rv_process) type zprce_data.
endclass.                    &quot;lcl_processor DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_processor IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_processor implementation.
  method constructor.
    mr_process = ir_process.
  endmethod.                    &quot;constructor

  method serialize.
    call transformation id_indent
     source obj = mr_process
     result xml rv_process.
  endmethod.                    &quot;serialize
  method dispatch.
    data: lv_data type zprce_data,
          lv_time type t.

    get time field lv_time.
    do.

      &quot;... Get the serialized data
      lv_data = serialize( ).

      call function &apos;Z_PRC_RUN_ISOLATED_TASK&apos; starting new task &apos;&apos; destination in group default
        exporting
          iv_process = lv_data
          iv_delay   = mr_process-&gt;mv_delay
        exceptions
          system_failure = 1
          communication_failure = 2
          resource_failure = 3.

        case sy-subrc.
          when 0.
            exit. &quot;... Exit the do loop to complete the method
          when 3.
            &quot;... Do nothing because we are waiting
          when others.
            &quot;... Explode in other cases
            raise exception type zcx_prc_system_failure.
        endcase.

      get time. &quot;... Init the system time to be sure
      if ( ( sy-uzeit - lv_time ) mod 86400 ) gt mr_process-&gt;mv_timeout.
        &quot;... Wait time is over
        raise exception type zcx_prc_wait_timout_exception.
      endif.
    enddo.
  endmethod.                   &quot;dispatch
endclass.                    &quot;lcl_processor IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section
class lcl_processor definition deferred.
class ZCL_PRC_ISOLATED_TASK definition local friends lcl_processor.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="MR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="MV_DELAY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="MV_TIMEOUT" VERSION="1" LANGU="E" DESCRIPT="Timeout in seconds" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTVALUE="299" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE"/>
   <parameter CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Seconds, yes as a char e.g. &apos;2&apos; or &apos;0.2&apos; dont ask" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <source>method constructor.
  data: lv_p type p decimals 2.
  lv_p = iv_delay.
  if lv_p gt 45.
    raise exception type zcx_prc_excessive_delay.
  endif.
  mr_runnable = ir_runnable.
  mv_delay = iv_delay.
endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="START" VERSION="1" LANGU="E" DESCRIPT="Start the process" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="START" SCONAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_ISOLATED_TASK" CMPNAME="START" SCONAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="2 "/>
   <source>method START.
    data: lr_processor type ref to lcl_processor.

    create object lr_processor
      exporting
        ir_process = me.

    lr_processor-&gt;dispatch( ).
  endmethod.                    &quot;START</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_SYSTEM_FAILURE" VERSION="1" LANGU="E" DESCRIPT="System Fail" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_SYSTEM_FAILURE" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_WP_MANAGER" VERSION="1" LANGU="E" DESCRIPT="Gets work process related details" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_WP_MANAGER" CMPNAME="CO_DEFAULT_MAX" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="10" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_WP_MANAGER" CMPNAME="MT_USERS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="2 " SRCCOLUMN1="16 " SRCROW2="2 " SRCCOLUMN2="86 " TYPESRC_LENG="73 " TYPESRC="mt_users type hashed table of zprcc_wp_config with unique key user_name
"/>
  <method CLSNAME="ZCL_PRC_WP_MANAGER" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method class_constructor.
    select * from zprcc_wp_config into table mt_users.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_WP_MANAGER" CMPNAME="GET_MAX_WORK_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Gets max work processes by user" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_WP_MANAGER" CMPNAME="GET_MAX_WORK_PROCESSES" SCONAME="USER" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST_UNAME" PARVALUE="SY-UNAME"/>
   <parameter CLSNAME="ZCL_PRC_WP_MANAGER" CMPNAME="GET_MAX_WORK_PROCESSES" SCONAME="MAX_WP" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method get_max_work_processes.
    read table mt_users into data(ls_user) with key user_name = user.

    if ls_user is not initial.
      max_wp = ls_user-max_wp.
    else.
      max_wp = co_default_max.
    endif.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_JOB_SCHEDULE" VERSION="1" LANGU="E" DESCRIPT="Used to add scheduling" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_JOB_SCHEDULE" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="HIGH_PRIORITY" VERSION="1" LANGU="E" DESCRIPT="Single-Character Flag" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;A&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="LOW_PRIORITY" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTVALUE="&apos;C&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="MEDIUM_PRIORITY" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTVALUE="&apos;B&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="_DATE" VERSION="1" LANGU="E" DESCRIPT="Field of type DATS" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="DATS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="_JOBNAME" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="_PRIORITY" VERSION="1" LANGU="E" DESCRIPT="Single-Character Flag" EXPOSURE="0" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="_TIME" VERSION="1" LANGU="E" DESCRIPT="Field of type TIMS" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TIMS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="CONSTRUCTOR" SCONAME="DATE" VERSION="1" LANGU="E" DESCRIPT="Field of type DATS" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="DATS" PARVALUE="SY-DATUM"/>
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="CONSTRUCTOR" SCONAME="TIME" VERSION="1" LANGU="E" DESCRIPT="Field of type TIMS" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="TIMS" PARVALUE="SY-UZEIT"/>
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="CONSTRUCTOR" SCONAME="JOBNAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING" PARVALUE="&apos;Z_PRC_BACKGROUND_JOB&apos;"/>
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="CONSTRUCTOR" SCONAME="PRIORITY" VERSION="1" LANGU="E" DESCRIPT="Single-Character Flag" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR1" PARVALUE="MEDIUM_PRIORITY"/>
   <source>method constructor.

    _date = date.
    _time = time.
    _jobname = jobname.
    _priority = priority.

    if sy-uzeit gt _time and sy-datum eq _date.
      _date = _date + 1. &quot;... Increment this
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="DATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="DATE" SCONAME="DATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="DATS"/>
   <source>method DATE.
    date = _date.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="JOBNAME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="JOBNAME" SCONAME="JOBNAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method JOBNAME.
    jobname = _jobname.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="PRIORITY" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="PRIORITY" SCONAME="PRIORITY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR1"/>
   <source>method PRIORITY.
    priority = _priority.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="TIME" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_JOB_SCHEDULE" CMPNAME="TIME" SCONAME="TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TIMS"/>
   <source>method TIME.
    time = _time.
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_EXAMPLE" VERSION="1" LANGU="E" DESCRIPT="Test Example" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_EXAMPLE" REFCLSNAME="ZIF_PRC_RUNNABLE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="2 "/>
  <implementing CLSNAME="ZCL_PRC_EXAMPLE" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_EXAMPLE" CMPNAME="MV_COUNT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_PRC_EXAMPLE" CPDNAME="ZIF_PRC_RUNNABLE~RUN">
   <source>method zif_prc_runnable~run.
  &quot;... Do something that takes a long time
  write &apos;inside runnable&apos;.
endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_MONITOR_BUILDER" VERSION="1" LANGU="E" DESCRIPT="Builder for the PRC Monitor Shared Area" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_MONITOR_BUILDER" REFCLSNAME="IF_SHM_BUILD_INSTANCE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <interfaceMethod CLSNAME="ZCL_PRC_MONITOR_BUILDER" CPDNAME="IF_SHM_BUILD_INSTANCE~BUILD">
   <source>method if_shm_build_instance~build.
  data:
  lr_area type ref to zcl_prc_monitor_area,
  lr_root type ref to zcl_prc_monitor_access,
  lr_exc type ref to cx_root.

  try.
      lr_area = zcl_prc_monitor_area=&gt;attach_for_write( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
    catch cx_shm_error into lr_exc.
      raise exception type cx_shm_build_failed
        exporting
          previous = lr_exc.
  endtry.

  create object lr_root area handle lr_area.
  lr_area-&gt;set_root( lr_root ).

  try.
      lr_area-&gt;detach_commit( ).
    catch cx_root into lr_exc.
*      raise exception type cx_shm_build_failed
*        exporting
*          previous = lr_exc.
  endtry.

  if invocation_mode = cl_shm_area=&gt;invocation_mode_auto_build.
    call function &apos;DB_COMMIT&apos;.
  endif.
endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_MONITOR" VERSION="1" LANGU="E" DESCRIPT="PRC Process Monitor" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_PRC_MONITOR" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="ATTACH_WP" VERSION="1" LANGU="E" DESCRIPT="Attaches the current WP to the Process" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="ATTACH_WP" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method attach_wp.
    data: lr_area type ref to zcl_prc_monitor_area,
          lr_monitor type ref to zcl_prc_monitor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_monitor_area=&gt;attach_for_update( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_monitor = lr_area-&gt;root.

    lr_monitor-&gt;attach_wp( iv_pid ).
    lr_area-&gt;detach_commit( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="DEREGISTER_PID" VERSION="1" LANGU="E" DESCRIPT="Deregister process by input ID" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="DEREGISTER_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method deregister_pid.
    data: lr_area type ref to zcl_prc_monitor_area,
          lr_monitor type ref to zcl_prc_monitor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_monitor_area=&gt;attach_for_update( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
          exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_monitor = lr_area-&gt;root.

    lr_monitor-&gt;deregister_pid( iv_pid ).
    lr_area-&gt;detach_commit( ).
  endmethod.                    &quot;DEREGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="GARBAGE_COLLECT" VERSION="1" LANGU="E" DESCRIPT="Cleans broken processes out" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="GARBAGE_COLLECT" SCONAME="IV_BYPASS_LONGCHK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
   <source>method garbage_collect.
    data: lr_area type ref to zcl_prc_monitor_area,
          lr_monitor type ref to zcl_prc_monitor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_monitor_area=&gt;attach_for_update( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_monitor = lr_area-&gt;root.

    lr_monitor-&gt;garbage_collect( iv_bypass_longchk ).
    lr_area-&gt;detach_commit( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="GET_WP_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Check if work processes are available for the user" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="GET_WP_AVAIL" SCONAME="RV_WP_AVAIL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method get_wp_avail.
  data: lr_area type ref to zcl_prc_monitor_area,
        lr_monitor type ref to zcl_prc_monitor_access,
        lr_exc type ref to cx_shm_attach_error,
        rv_cleaned type abap_bool,
        lv_time type t.

  &quot;... Do any GC first
  garbage_collect( ).

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_monitor_area=&gt;attach_for_read( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
        exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_monitor = lr_area-&gt;root.

  rv_wp_avail = lr_monitor-&gt;get_wp_avail( ).
  lr_area-&gt;detach( ).

  case rv_wp_avail.
    when -1. &quot;... Not initialised
      &quot;... Initialise the work processes to default, can return that value here
      rv_wp_avail = zcl_prc_wp_manager=&gt;get_max_work_processes( ).
      max_work_processes( rv_wp_avail ).
    when 0.
      garbage_collect( ).
  endcase.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="HAS_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Check if the user / session ID has processes running" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="HAS_PROCESSES" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_processes.
  data: lr_area type ref to zcl_prc_monitor_area,
        lr_monitor type ref to zcl_prc_monitor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

  &quot;... Do any GC first(bypassing the time wait)
  garbage_collect( abap_true ).

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_monitor_area=&gt;attach_for_read( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
        exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_monitor = lr_area-&gt;root.

  rv_result = lr_monitor-&gt;has_processes( ).
  lr_area-&gt;detach( ).

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="MAX_WORK_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Set the number of parallel processes to launch" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="MAX_WORK_PROCESSES" SCONAME="IV_NUM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method max_work_processes.
  data: lr_area type ref to zcl_prc_monitor_area,
        lr_monitor type ref to zcl_prc_monitor_access,
        lr_exc type ref to cx_shm_attach_error,
        lv_time type t.

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_monitor_area=&gt;attach_for_update( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
        exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_monitor = lr_area-&gt;root.

  lr_monitor-&gt;number_of_processes( iv_num ).
  lr_area-&gt;detach_commit( ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="PID_EXISTS" VERSION="1" LANGU="E" DESCRIPT="Check if the input ID exists" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="PID_EXISTS" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="PID_EXISTS" SCONAME="RV_EXISTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method pid_exists.
  data: lr_area type ref to zcl_prc_monitor_area,
        lr_monitor type ref to zcl_prc_monitor_access,
        lr_exc type ref to cx_shm_attach_error,
        lv_time type t.

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_monitor_area=&gt;attach_for_read( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
        exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_monitor = lr_area-&gt;root.

  rv_exists = lr_monitor-&gt;pid_exists( iv_pid ).
  lr_area-&gt;detach( ).
endmethod.                    &quot;PID_EXISTS</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR" CMPNAME="REGISTER_PID" VERSION="1" LANGU="E" DESCRIPT="Register process returning the ID" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR" CMPNAME="REGISTER_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <exception CLSNAME="ZCL_PRC_MONITOR" CMPNAME="REGISTER_PID" SCONAME="ZCX_PRC_NO_PROCESSES_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Raised when no proceses available for user" MTDTYPE="0" EDITORDER="1 "/>
   <source>method register_pid.
  data: lr_area type ref to zcl_prc_monitor_area,
        lr_monitor type ref to zcl_prc_monitor_access,
        lr_exc type ref to cx_shm_attach_error,
        lv_time type t.

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_monitor_area=&gt;attach_for_update( &apos;ZCL_PRC_MONITOR_AREA&apos; ).
        exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_monitor = lr_area-&gt;root.

  try.
      rv_pid = lr_monitor-&gt;register_pid( ).
    catch zcx_prc_no_processes_avail.
  endtry.
  lr_area-&gt;detach_commit( ).
endmethod.                    &quot;REGISTER_PID</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_EXECUTOR_BUILDER" VERSION="1" LANGU="E" DESCRIPT="Builder for the PRC Executor Shared Area" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_EXECUTOR_BUILDER" REFCLSNAME="IF_SHM_BUILD_INSTANCE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <interfaceMethod CLSNAME="ZCL_PRC_EXECUTOR_BUILDER" CPDNAME="IF_SHM_BUILD_INSTANCE~BUILD">
   <source>method IF_SHM_BUILD_INSTANCE~BUILD.
  data:
  lr_area type ref to zcl_prc_executor_area,
  lr_root type ref to zcl_prc_executor_access,
  lr_exc type ref to cx_root.

  try.
      lr_area = zcl_prc_executor_area=&gt;attach_for_write( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
    catch cx_shm_error into lr_exc.
      raise exception type cx_shm_build_failed
        exporting
          previous = lr_exc.
  endtry.

  create object lr_root area handle lr_area.
  lr_area-&gt;set_root( lr_root ).

  try.
      lr_area-&gt;detach_commit( ).
    catch cx_root into lr_exc.
*      raise exception type cx_shm_build_failed
*        exporting
*          previous = lr_exc.
  endtry.

  if invocation_mode = cl_shm_area=&gt;invocation_mode_auto_build.
    call function &apos;DB_COMMIT&apos;.
  endif.
endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" VERSION="1" LANGU="E" DESCRIPT="Serialise and deserialise data references" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <method CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="DESERIALIZE_RESULT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="DESERIALIZE_RESULT" SCONAME="IV_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZPRCE_DATA"/>
   <parameter CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="DESERIALIZE_RESULT" SCONAME="ER_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="DESERIALIZE_RESULT" SCONAME="ZCX_PRC_RETURN_TYPE_MISMATCH" VERSION="1" LANGU="E" DESCRIPT="A Result object ref was used that cant be serialized" MTDTYPE="0" EDITORDER="1 "/>
   <source>method deserialize_result.
  try.
      call transformation id_indent
      source xml iv_data
      result obj = er_result.
    catch cx_xslt_format_error.
      raise exception type zcx_prc_return_type_mismatch.
  endtry.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="SERIALIZE_RESULT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="SERIALIZE_RESULT" SCONAME="IR_RESULT" VERSION="1" LANGU="E" DESCRIPT="This needs to be a serializable of course" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="SERIALIZE_RESULT" SCONAME="RV_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZPRCE_DATA"/>
   <exception CLSNAME="ZCL_PRC_SERIALIZATION_UTIL" CMPNAME="SERIALIZE_RESULT" SCONAME="ZCX_PRC_NON_SERIALIZABLE" VERSION="1" LANGU="E" DESCRIPT="A Result object ref was used that cant be serialized" MTDTYPE="0" EDITORDER="1 "/>
   <source>method serialize_result.
  try.
      call transformation id_indent
      source obj = ir_result
      result xml rv_data.
    catch cx_root.
      raise exception type zcx_prc_non_serializable.
  endtry.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" VERSION="1" LANGU="E" DESCRIPT="PRC Completion Monitor Access(in shared memory)" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" CLSSHAREDMEMORY="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="REGISTRATION" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="25 " TYPESRC_LENG="185 " TYPESRC="begin of registration,
            pid type char8,
            uname like sy-uname,
            wp_id type char8,
            mod_time type timestampl,
       end of registration
"/>
  <types CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="COUNT_ENTRY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="17 " SRCCOLUMN2="27 " TYPESRC_LENG="147 " TYPESRC="begin of count_entry,
            uname like sy-uname,
            wp_max type i,
            wp_counter type i,
          end of count_entry
"/>
  <friends CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" REFCLSNAME="ZCL_PRC_EXECUTOR_BUILDER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" REFCLSNAME="ZCL_PRC_FUTURE_EXECUTOR" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" REFCLSNAME="ZCL_PRC_FUTURE_TASK" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="MT_AVAIL_PIDS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="23 " SRCCOLUMN2="41 " TYPESRC_LENG="40 " TYPESRC="mt_avail_pids type standard table of i
"/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="MT_REGISTER" VERSION="1" LANGU="E" DESCRIPT="Process Register" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="68 " TYPESRC_LENG="67 " TYPESRC="mt_register type sorted table of registration with unique key pid
"/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="MT_WP_COUNT" VERSION="1" LANGU="E" DESCRIPT="Work Process Count" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="25 " SRCCOLUMN1="4 " SRCROW2="25 " SRCCOLUMN2="69 " TYPESRC_LENG="68 " TYPESRC="mt_wp_count type hashed table of count_entry with unique key uname
"/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="MV_PROCESS_COUNT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="ATTACH_WP" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="ATTACH_WP" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method attach_wp.
    field-symbols: &lt;fs_register&gt; like line of mt_register.

    read table mt_register with table key pid = iv_pid assigning &lt;fs_register&gt;.
    &lt;fs_register&gt;-wp_id = get_wp_id( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method constructor.
    data: lv_count type i value 1,
          lv_pid type num8.

    &quot;... Setup a buffer of PIDS
    do 10000 times.
      lv_pid = lv_count.
      append lv_pid to mt_avail_pids.

      lv_count = lv_count + 1.
    enddo.

    mv_process_count = mv_process_count + 1000.

    &quot;... Clear any old completed stuff
    delete from zprcd_completed.
  endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="DEREGISTER_PID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="DEREGISTER_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method deregister_pid.
    delete table mt_register with table key pid = iv_pid.

    set_wp_avail( get_wp_avail( ) + 1 ).

    &quot;... Push the PID back as an available id
    push_pid( iv_pid ).

  endmethod.                    &quot;DEREGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GARBAGE_COLLECT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GARBAGE_COLLECT" SCONAME="IV_BYPASS_LONGCHK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
   <source>method garbage_collect.
    data: lt_wpinfo type standard table of wpinfo,
          ls_wpinfo type wpinfo,
          ls_register like line of mt_register,
          lt_pids type standard table of char8,
          lv_check type abap_bool,
          lv_pid type char8.

    if get_wp_avail( ) eq 0 or iv_bypass_longchk eq abap_true.
      lv_check = abap_true.
    elseif has_long_process( ) eq abap_true.
      lv_check = abap_true.
    endif.

    if lv_check eq abap_true.
      call function &apos;TH_WPINFO&apos;
        tables
          wplist     = lt_wpinfo
        exceptions
          send_error = 1
          others     = 2.

      loop at mt_register into ls_register where uname eq sy-uname.
        if ls_register-wp_id is initial.
          &quot;... Process hasnt started yet
          continue.
        endif.
        read table lt_wpinfo with key wp_bname = sy-uname wp_pid = ls_register-wp_id into ls_wpinfo.
        if sy-subrc ne 0.
          append ls_register-pid to lt_pids.
        endif.
      endloop.
      loop at lt_pids into lv_pid.
        deregister_pid( lv_pid ).
      endloop.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_RESULT" VERSION="1" LANGU="E" DESCRIPT="Get the result" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_RESULT" SCONAME="IV_GUID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_X16"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_RESULT" SCONAME="RV_RESULT" VERSION="1" LANGU="E" DESCRIPT="PRC Data" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZPRCE_DATA"/>
   <source>method get_result.
  data: ls_completion type zprcd_completed.
  field-symbols: &lt;fs_any&gt; type any.
*  read table mt_completed into ls_completion with table key guid = iv_guid.
  select single * from zprcd_completed into ls_completion where guid = iv_guid.

  if sy-subrc eq 0.
    delete from zprcd_completed where guid = iv_guid.

    rv_result = ls_completion-data.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_WP_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Number of parallel processes avail for user / session id" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_WP_AVAIL" SCONAME="RV_WP_AVAIL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method get_wp_avail.
    data: ls_count_entry type count_entry.

    read table mt_wp_count with table key uname = sy-uname into ls_count_entry.

    &quot;... User has a count return it
    if sy-subrc eq 0.
      rv_wp_avail = ls_count_entry-wp_counter.
    else.
      &quot;... If no count avail return a -1 to indicate so it can be initialised via change lock
      rv_wp_avail = -1.
    endif.
  endmethod.                    &quot;GET_WP_AVAIL</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_WP_ID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_WP_ID" SCONAME="RV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method get_wp_id.
    &quot;... Get the PID for the current work process
    call function &apos;TH_GET_OWN_WP_NO&apos;
      importing
        wp_pid   = rv_pid.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_WP_MAX" VERSION="1" LANGU="E" DESCRIPT="Maximum parallel processes for user / session id" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="GET_WP_MAX" SCONAME="RV_WP_MAX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method get_wp_max.
    data: ls_count_entry type count_entry.
    read table mt_wp_count with table key uname = sy-uname into ls_count_entry.

    &quot;... User has a max set return it
    if sy-subrc eq 0.
      rv_wp_max = ls_count_entry-wp_max.
    else.
      &quot;... no max so we will set one up()
      number_of_processes( zcl_prc_wp_manager=&gt;get_max_work_processes( ) ).
    endif.
  endmethod.                    &quot;GET_WP_MAX</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="HAS_LONG_PROCESS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="HAS_LONG_PROCESS" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_long_process.
    data: ls_register like line of mt_register,
          lv_time type timestampl,
          lv_secs type tzntstmpl.

    &quot;... Get current time
    get time stamp field lv_time.

    loop at mt_register into ls_register where uname = sy-uname.
      lv_secs = cl_abap_tstmp=&gt;subtract( tstmp1 = lv_time
                                         tstmp2 = ls_register-mod_time ).
      if lv_secs gt 120.
        rv_result = abap_true.
        return.
      endif.
    endloop.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="HAS_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Check if processes exist(by username)" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="HAS_PROCESSES" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_processes.
   data: ls_count_entry type count_entry.

    read table mt_wp_count with table key uname = sy-uname into ls_count_entry.

    if ls_count_entry-wp_counter lt ls_count_entry-wp_max.
      rv_result = abap_true.
    endif.
  endmethod.                    &quot;has_processes</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="INCREASE_PID_BUFFER" VERSION="1" LANGU="E" DESCRIPT="Increase the buffer of available PIDS" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="INCREASE_PID_BUFFER" SCONAME="IV_THRESHHOLD" VERSION="1" LANGU="E" DESCRIPT="How many more to generate" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method increase_pid_buffer.
  endmethod.                    &quot;INCREASE_PID_BUFFER</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="IS_COMPLETE" VERSION="1" LANGU="E" DESCRIPT="Check if the callable completed" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="IS_COMPLETE" SCONAME="IV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="IS_COMPLETE" SCONAME="IV_GUID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_X16"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="IS_COMPLETE" SCONAME="RV_COMPLETE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="IS_COMPLETE" SCONAME="ZCX_PRC_PROCESS_FAILED" VERSION="1" LANGU="E" DESCRIPT="The process failed already during execution, check error trc" MTDTYPE="0" EDITORDER="1 "/>
   <source>method is_complete.
  data: ls_registration type registration,
        lv_cnt type i.

  select count(*) from zprcd_completed into lv_cnt where guid = iv_guid.

  if lv_cnt gt 0.
    rv_complete = abap_true.
    return.
  endif.

  &quot;... If the item is not still registered then there is a major issue
  read table mt_register with key uname = sy-uname pid = iv_pid transporting no fields.
  if sy-subrc ne 0.
    raise exception type zcx_prc_process_failed.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="NUMBER_OF_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Set the number of processes to use" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="NUMBER_OF_PROCESSES" SCONAME="IV_NUM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method number_of_processes.
    data: lv_chk type i,
          ls_count_entry type count_entry.
    field-symbols: &lt;fs_count_entry&gt; type count_entry.
    read table mt_wp_count with table key uname = sy-uname assigning &lt;fs_count_entry&gt;.

    if sy-subrc eq 0.
      if iv_num ne &lt;fs_count_entry&gt;-wp_max.
        lv_chk = iv_num - ( &lt;fs_count_entry&gt;-wp_max - &lt;fs_count_entry&gt;-wp_counter ).

        if lv_chk ge 0.
          &lt;fs_count_entry&gt;-wp_counter = lv_chk.
        else.
          &lt;fs_count_entry&gt;-wp_counter = 0.
        endif.
      endif.
      &lt;fs_count_entry&gt;-wp_max = iv_num.
    else.
      ls_count_entry-uname = sy-uname.
      ls_count_entry-wp_max = iv_num.
      ls_count_entry-wp_counter = iv_num.
      insert ls_count_entry into table mt_wp_count.
    endif.

  endmethod.                    &quot;NUMBER_OF_PROCESSES</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="PID_EXISTS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="PID_EXISTS" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="PID_EXISTS" SCONAME="RV_EXISTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method pid_exists.
    read table mt_register with table key pid = iv_pid transporting no fields.

    case sy-subrc.
      when 0.
        rv_exists = abap_true.
    endcase.
  endmethod.                    &quot;PID_EXISTS</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="POP_PID" VERSION="1" LANGU="E" DESCRIPT="Pop the next PID off the list" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="POP_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method pop_pid.
    data: lv_num type num8.
    read table mt_avail_pids into lv_num index 1.
    delete mt_avail_pids index 1.
    rv_pid = lv_num.
  endmethod.                    &quot;POP_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="PUSH_PID" VERSION="1" LANGU="E" DESCRIPT="Push a PID back onto the available list" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="PUSH_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method push_pid.
    data: lv_pid type i.
    lv_pid = iv_pid.
    append lv_pid to mt_avail_pids.
  endmethod.                    &quot;PUSH_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="REGISTER_PID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="REGISTER_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="REGISTER_PID" SCONAME="ZCX_PRC_NO_PROCESSES_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Raised when no proceses available for user" MTDTYPE="0" EDITORDER="1 "/>
   <source>method register_pid.
    data: lv_num type num8,
          lv_wp_avail type i,
          ls_register type registration.

    lv_wp_avail = get_wp_avail( ).
    if lv_wp_avail eq 0.
      raise exception type zcx_prc_no_processes_avail.
    endif.

    &quot;... Get the next available PID
    rv_pid = pop_pid( ).

    ls_register-pid = rv_pid.
    ls_register-uname = sy-uname.
    get time stamp field ls_register-mod_time.
    insert ls_register into table mt_register.
    set_wp_avail( lv_wp_avail - 1 ).
  endmethod.                    &quot;REGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_RESULT" VERSION="1" LANGU="E" DESCRIPT="Set the result for the execution" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_RESULT" SCONAME="IV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_RESULT" SCONAME="IV_GUID" VERSION="1" LANGU="E" DESCRIPT="16 Byte UUID in 16 Bytes (Raw Format)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_X16"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_RESULT" SCONAME="IV_RESULT" VERSION="1" LANGU="E" DESCRIPT="PRC Data" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZPRCE_DATA"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_RESULT" SCONAME="IV_WPID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method set_result.
  data: ls_complete type zprcd_completed.

  ls_complete-guid = iv_guid.
  ls_complete-data = iv_result.
  ls_complete-wpid = iv_wpid.
  get time stamp field ls_complete-time.
  insert zprcd_completed from ls_complete.

  &quot;... Deregister the process
  deregister_pid( iv_pid ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_WP_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Set the current wp count for user / session id" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_ACCESS" CMPNAME="SET_WP_AVAIL" SCONAME="IV_WP_AVAIL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method set_wp_avail.
    field-symbols: &lt;fs_count_entry&gt; type count_entry.
    read table mt_wp_count with table key uname = sy-uname assigning &lt;fs_count_entry&gt;.

    &quot;... This is a major explosion if its ne 0
    if sy-subrc ne 0.
      raise exception type zcx_prc_process_exception.
    else.
      &lt;fs_count_entry&gt;-wp_counter = iv_wp_avail.
    endif.
  endmethod.                    &quot;SET_WP_AVAIL</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_NON_SERIALIZABLE" VERSION="1" LANGU="E" DESCRIPT="A Result object ref was used that cant be serialized" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_NON_SERIALIZABLE" REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Generic exception for paralell processes" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_PROCESS_EXCEPTION" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Timeout when waiting occurred" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_COLLECTION" VERSION="1" LANGU="E" DESCRIPT="A Collection Implementation" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_COLLECTION" REFCLSNAME="ZIF_COLLECTION" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <implementing CLSNAME="ZCL_PRC_COLLECTION" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="2 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_iterator definition .
  public section.
    interfaces zif_iterator .
    methods constructor
      importing
        ir_collection type ref to zif_collection.
  protected section.

  private section.
    data: mr_collection type ref to zif_collection,
          mv_index type i value 1.

endclass.                    &quot;lcl_iterator DEFINITION
&quot;lcl_iterator DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_iterator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_iterator implementation.
  method constructor.
    mr_collection = ir_collection.
  endmethod.                    &quot;constructor
  method zif_iterator~get_index.
    rv_index = mv_index.
  endmethod.                    &quot;zif_iterator~GET_INDEX

  method zif_iterator~has_next.
    if mv_index lt mr_collection-&gt;size( ).
      rv_hasnext = abap_true.
    else.
      rv_hasnext = abap_false.
    endif.
  endmethod.                    &quot;zif_iterator~HAS_NEXT
  method zif_iterator~next.
    mv_index = mv_index + 1.
    rr_object = mr_collection-&gt;get_item( mv_index ).
  endmethod.                    &quot;zif_iterator~NEXT

  method zif_iterator~current.
    rr_object = mr_collection-&gt;get_item( mv_index ).
  endmethod.                    &quot;zif_iterator~current
  method zif_iterator~first.
    mv_index = 1.
    rr_object = mr_collection-&gt;get_item( mv_index ).
  endmethod.                    &quot;zif_iterator~first

  method zif_iterator~last.
    mv_index = mr_collection-&gt;size( ).
    rr_object = mr_collection-&gt;get_item( mv_index ).
  endmethod.                    &quot;zif_iterator~last

endclass.                    &quot;lcl_iterator IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="MT_COLLECTION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="53 " TYPESRC_LENG="52 " TYPESRC="MT_COLLECTION type standard table of ref to object
"/>
  <interfaceMethod CLSNAME="ZCL_PRC_COLLECTION" CPDNAME="ZIF_COLLECTION~GET_ITEM">
   <source>method ZIF_COLLECTION~GET_ITEM.
  read table mt_collection into rr_object index iv_index.
endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_PRC_COLLECTION" CPDNAME="ZIF_COLLECTION~GET_ITERATOR">
   <source>method ZIF_COLLECTION~GET_ITERATOR.
  create object rif_iterator type lcl_iterator
    exporting
      ir_collection = me.
endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_PRC_COLLECTION" CPDNAME="ZIF_COLLECTION~IS_EMPTY">
   <source>method ZIF_COLLECTION~IS_EMPTY.
  if me-&gt;zif_collection~size( ) eq 0.
    rv_empty = abap_true.
  else.
    rv_empty = abap_false.
  endif.
endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_PRC_COLLECTION" CPDNAME="ZIF_COLLECTION~SIZE">
   <source>method ZIF_COLLECTION~SIZE.
  rv_size = lines( mt_collection ).
endmethod.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="ADD" VERSION="1" LANGU="E" DESCRIPT="Add an item to the collection" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="ADD" SCONAME="IR_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Item to add to the collection" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="OBJECT"/>
   <source>method ADD.
  append ir_object to mt_collection.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="CLEAR" VERSION="1" LANGU="E" DESCRIPT="Clear the collection" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLEAR.
  clear mt_collection.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="REMOVE" VERSION="1" LANGU="E" DESCRIPT="Delete an item from the collection" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="REMOVE" SCONAME="IR_ITEM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="OBJECT"/>
   <source>method REMOVE.
  delete table mt_collection from ir_item.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="REMOVE_INDEX" VERSION="1" LANGU="E" DESCRIPT="Delete an item from the collection" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_COLLECTION" CMPNAME="REMOVE_INDEX" SCONAME="IV_INDEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method REMOVE_INDEX.
  delete mt_collection index iv_index.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_PROCESS_FAILED" VERSION="1" LANGU="E" DESCRIPT="The process failed already during execution, check error tra" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_PROCESS_FAILED" REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_RETURN_TYPE_MISMATCH" VERSION="1" LANGU="E" DESCRIPT="The return type expected differred from the expected result" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_RETURN_TYPE_MISMATCH" REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_NO_PROCESSES_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Raised when no proceses available for user" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_NO_PROCESSES_AVAIL" REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_LOCKED" VERSION="1" LANGU="E" DESCRIPT="Lock key is currently Locked" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_LOCKED" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_EXECUTOR_AREA" VERSION="1" LANGU="E" DESCRIPT="PRC Executor Area class" CATEGORY="45" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="S" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CL_SHM_AREA">
  <friends CLSNAME="ZCL_PRC_EXECUTOR_AREA" REFCLSNAME="CL_SHM_AREA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class

DEFINE mc_set_shm_client.

  if client is supplied.
    l_client = client.
    l_client_supplied = abap_true.
  else.
    l_client = cl_abap_syst=&gt;get_client( ).
  endif.

END-OF-DEFINITION.

DEFINE mc_set_shm_client_attach_only.

  l_client = cl_abap_syst=&gt;get_client( ).

END-OF-DEFINITION.</localMacros>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="AREA_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of an Area Class" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZCL_PRC_EXECUTOR_AREA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_AREA_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ROOT" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of a Data Class" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_PRC_EXECUTOR_ACCESS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="_CLIENT_DEPENDENT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_TRUE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="_LIFE_CONTEXT" VERSION="1" LANGU="E" DESCRIPT="Lifetime of an Area (Constants in CL_SHM_AREA)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="CL_SHM_AREA=&gt;LIFE_CONTEXT_APPSERVER" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_LIFE_CONTEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="_TRACE_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="(Internal) Flag: Trace Active?" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="_TRACE_SERVICE" VERSION="1" LANGU="E" DESCRIPT="(Internal) Reference to Trace Class" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="IF_SHM_TRACE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="_TRANSACTIONAL" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="_VERSION_" VERSION="1" LANGU="E" DESCRIPT="(internal)" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="20" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_PRC_EXECUTOR_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_PRC_EXECUTOR_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" MTDNAME="GET_ROOT" EXPOSURE="0"/>
  </inheritance>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" VERSION="1" LANGU="E" DESCRIPT="Request a Read Lock" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="HANDLE" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_EXECUTOR_AREA"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="E" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="E" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_READ_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Request for a Second Read Lock" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="A Change Lock Is Already Active" MTDTYPE="0" EDITORDER="6 "/>
   <source>method ATTACH_FOR_READ.

  DATA:
    l_attributes       TYPE shma_attributes,
    l_root             TYPE REF TO object,
    l_cx               TYPE REF TO cx_root,
    l_client           TYPE shm_client,
    l_client_supplied  TYPE abap_bool. &quot;#EC NEEDED

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.

  mc_set_shm_client_attach_only.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_read = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

*   try sneak mode first
    handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                      sneak_mode   = abap_true
                                      life_context = _life_context
                            IMPORTING root         = l_root ).

    IF l_root IS INITIAL.
*     no root object returned, sneak mode was not successful.
*     -&gt; read area properties from database and try again.
      cl_shm_service=&gt;initialize(
        EXPORTING area_name       = handle-&gt;area_name
                  client          = l_client
        IMPORTING attributes      = l_attributes
      ).

      handle-&gt;properties = l_attributes-properties.
      handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                        sneak_mode   = abap_false
                                        life_context = _life_context
                              IMPORTING root         = l_root ).

    ENDIF.

    handle-&gt;root ?= l_root.
*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                          sneak_mode   = abap_true
                                          life_context = _life_context
                                IMPORTING root         = l_root ).

        IF l_root IS INITIAL.
*         no root object returned, sneak mode was not successful.
*         -&gt; read area properties from database and try again.
          cl_shm_service=&gt;initialize(
            EXPORTING area_name       = handle-&gt;area_name
                      client          = l_client
            IMPORTING attributes      = l_attributes
          ).

          handle-&gt;properties = l_attributes-properties.
          handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                            sneak_mode   = abap_false
                                            life_context = _life_context
                                  IMPORTING root         = l_root ).

        ENDIF.
        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" VERSION="1" LANGU="E" DESCRIPT="Request a Change Lock" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="E" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="WAIT_TIME" VERSION="1" LANGU="E" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="HANDLE" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_EXECUTOR_AREA"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="E" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="E" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="E" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="6 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="E" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="7 "/>
   <source>method ATTACH_FOR_UPDATE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_root                   TYPE REF TO object,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.

  mc_set_shm_client_attach_only.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_upd = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_update70(
      EXPORTING area_name = handle-&gt;area_name
                mode      = attach_mode
      IMPORTING root      = l_root
      CHANGING  wait_time = l_wait_time ).

    IF abap_true = l_attributes-properties-has_versions AND
       handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
      handle-&gt;_attach_update70(
        EXPORTING area_name = handle-&gt;area_name
                  mode      = attach_mode
        IMPORTING root      = l_root
        CHANGING  wait_time = l_wait_time ).
    ENDIF.

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

      ENDWHILE.

    ENDIF.

    handle-&gt;root ?= l_root.

*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = attach_mode
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = attach_mode
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_update70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              IMPORTING
                root      = l_root
              CHANGING
                wait_time = l_wait_time ).

            IF abap_true = l_attributes-properties-has_versions AND
               handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
              handle-&gt;_attach_update70(
                EXPORTING
                  area_name = handle-&gt;area_name
                  mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
                IMPORTING
                  root      = l_root
                CHANGING
                  wait_time = l_wait_time ).
            ENDIF.

          ENDWHILE.

        ENDIF.

        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" VERSION="1" LANGU="E" DESCRIPT="Request a Write Lock" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="E" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="WAIT_TIME" VERSION="1" LANGU="E" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="HANDLE" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_EXECUTOR_AREA"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="E" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="E" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="5 "/>
   <source>method ATTACH_FOR_WRITE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.

  mc_set_shm_client_attach_only.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_write = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_write70(
      EXPORTING
        area_name = handle-&gt;area_name
        mode      = attach_mode
      CHANGING
        wait_time = l_wait_time ).

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          CHANGING
            wait_time = l_wait_time ).

      ENDWHILE.

    ENDIF.

*   &lt;

  ELSE.

    TRY.

*     &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = attach_mode
          CHANGING
            wait_time = l_wait_time ).

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_write70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              CHANGING
                wait_time = l_wait_time ).

          ENDWHILE.

        ENDIF.

*     &lt;

        _trace_service-&gt;trin_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).
      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="BUILD" VERSION="1" LANGU="E" DESCRIPT="Direct Call of Area Constructor" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="BUILD" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_NOT_CONFIGURED" VERSION="1" LANGU="E" DESCRIPT="SHM Administration: Area Property Is Not Configured" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_INCONSISTENT" VERSION="1" LANGU="E" DESCRIPT="SHM Administration: Inconsistent Attribute Combination" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="BUILD" SCONAME="CX_SHM_BUILD_FAILED" VERSION="1" LANGU="E" DESCRIPT="Constructor Run Failed" MTDTYPE="0" EDITORDER="3 "/>
   <source>method BUILD.

  DATA:
    l_cls_name TYPE shm_auto_build_class_name,
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-build = abap_false.

*   &gt;
    l_cls_name =
      cl_shm_service=&gt;get_auto_build_class_name( area_name ).

    CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
      EXPORTING
        inst_name = inst_name.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        l_cls_name =
          cl_shm_service=&gt;get_auto_build_class_name( area_name ).

        CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
          EXPORTING
            inst_name = inst_name.
*       &lt;
        _trace_service-&gt;trin_build(
          area_name         = area_name
          inst_name         = inst_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_build(
          area_name         = area_name
          inst_name         = inst_name
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.

* TRACE { DO NOT REMOVE THIS LINE !
  _trace_active = abap_false.
  TRY.
      _trace_service =
        cl_shm_service=&gt;trace_get_service( area_name ).
      IF NOT _trace_service IS INITIAL.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      ENDIF.
    CATCH cx_root. &quot;#EC NO_HANDLER
                   &quot;#EC CATCH_ALL
  ENDTRY.
* TRACE } DO NOT REMOVE THIS LINE !

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="DETACH_AREA" VERSION="1" LANGU="E" DESCRIPT="Release all locks on all instances" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="DETACH_AREA" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="DETACH_AREA" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>method DETACH_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  mc_set_shm_client.

* &gt;
  rc = _detach_area71( area_name        = area_name
                       client           = l_client
                       client_supplied  = l_client_supplied
                       client_dependent = _client_dependent
                       life_context     = _life_context
       ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-detach_area = abap_true.
      _trace_service-&gt;trin_detach_area(
        area_name = area_name
        client    = l_client
        rc        = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_AREA" VERSION="1" LANGU="E" DESCRIPT="Delete all instances" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_AREA" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_AREA" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _free_area71( area_name         = area_name
                     client            = l_client
                     client_supplied   = l_client_supplied
                     client_dependent  = _client_dependent
                     transactional     = _transactional
                     terminate_changer = terminate_changer
                     affect_server     = affect_server
                     life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_area = abap_true.
      _trace_service-&gt;trin_free_area(
      area_name         = area_name
      client            = l_client
      terminate_changer = terminate_changer
      affect_server     = affect_server
      rc                = rc
    ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Deletion of an Instance" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _free_instance71( area_name         = area_name
                         inst_name         = inst_name
                         client            = l_client
                         client_supplied   = l_client_supplied
                         client_dependent  = _client_dependent
                         transactional     = _transactional
                         terminate_changer = terminate_changer
                         affect_server     = affect_server
                         life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_instance = abap_true.
      _trace_service-&gt;trin_free_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="GET_GENERATOR_VERSION" VERSION="1" LANGU="E" DESCRIPT="Query Generator Version" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="GET_GENERATOR_VERSION" SCONAME="GENERATOR_VERSION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_GENERATOR_VERSION.
  generator_version = _version_.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="GET_INSTANCE_INFOS" VERSION="1" LANGU="E" DESCRIPT="Returns the names of all instances" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance in an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INFOS" VERSION="1" LANGU="E" DESCRIPT="Overview of all Instances of an SHM Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_INST_INFOS"/>
   <source>method GET_INSTANCE_INFOS.

  DATA:
    l_client             TYPE shm_client,
    l_client_supplied    TYPE abap_bool VALUE abap_false,
    l_inst_name_supplied TYPE abap_bool VALUE abap_false.

  mc_set_shm_client.

  IF inst_name IS SUPPLIED.
    l_inst_name_supplied = abap_true.
  ENDIF.

* &gt;
  TRY.
      CALL METHOD (&apos;_GET_INSTANCE_INFOS804&apos;)
        EXPORTING
          area_name          = area_name
          client             = l_client
          client_supplied    = l_client_supplied
          client_dependent   = _client_dependent
          life_context       = _life_context
          inst_name          = inst_name
          inst_name_supplied = l_inst_name_supplied
        RECEIVING
          infos              = infos.
    CATCH cx_sy_dyn_call_illegal_method.
*     New kernel and/or new basis SP missing -&gt; use slow fallback
      infos = _get_instance_infos71(
                area_name        = area_name
                client           = l_client
                client_supplied  = l_client_supplied
                client_dependent = _client_dependent
                life_context     = _life_context
              ).
      IF abap_true = l_inst_name_supplied.
        DELETE infos WHERE name &lt;&gt; inst_name.
      ENDIF.
  ENDTRY.
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-get_instance_inf = abap_true.
      _trace_service-&gt;trin_get_instance_infos(
        area_name         = area_name
        client            = l_client
        infos             = infos
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="CL_SHM_AREA" CMPNAME="GET_ROOT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_ROOT.

  DATA:
    l_cx        TYPE REF TO cx_root,
    l_area_name TYPE string,
    l_inst_name TYPE string,
    l_client    TYPE string.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-get_root = abap_false.

*   &gt;
    IF is_valid( ) = abap_false.
      l_area_name = me-&gt;area_name.
      l_inst_name = me-&gt;inst_name.
      l_client    = me-&gt;client.
      RAISE EXCEPTION TYPE cx_shm_already_detached
        EXPORTING
          area_name = l_area_name
          inst_name = l_inst_name
          client    = l_client.
    ENDIF.
    root = me-&gt;root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        IF is_valid( ) = abap_false.
          l_area_name = me-&gt;area_name.
          l_inst_name = me-&gt;inst_name.
          l_client    = me-&gt;client.
          RAISE EXCEPTION TYPE cx_shm_already_detached
            EXPORTING
              area_name = l_area_name
              inst_name = l_inst_name
              client    = l_client.
        ENDIF.
        root = me-&gt;root.
*       &lt;

        _trace_service-&gt;trin_get_root(
          area_name = area_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_get_root(
          area_name = area_name
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_AREA" VERSION="1" LANGU="E" DESCRIPT="Active versions of all instances will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _invalidate_area71( area_name         = area_name
                           client            = l_client
                           client_supplied   = l_client_supplied
                           client_dependent  = _client_dependent
                           transactional     = _transactional
                           terminate_changer = terminate_changer
                           affect_server     = affect_server
                           life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_area = abap_true.
      _trace_service-&gt;trin_invalidate_area(
        area_name         = area_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Active version of one instance will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool value abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _invalidate_instance71(
    area_name         = area_name
    inst_name         = inst_name
    client            = l_client
    client_supplied   = l_client_supplied
    client_dependent  = _client_dependent
    transactional     = _transactional
    terminate_changer = terminate_changer
    affect_server     = affect_server
    life_context      = _life_context
  ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_inst = abap_true.
      _trace_service-&gt;trin_invalidate_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="SET_ROOT" VERSION="1" LANGU="E" DESCRIPT="Sets Root Objects" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="SET_ROOT" SCONAME="ROOT" VERSION="1" LANGU="E" DESCRIPT="Root object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_PRC_EXECUTOR_ACCESS"/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_INITIAL_REFERENCE" VERSION="1" LANGU="E" DESCRIPT="Initial Reference Passed" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_EXECUTOR_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_WRONG_HANDLE" VERSION="1" LANGU="E" DESCRIPT="Incorrect Handle" MTDTYPE="0" EDITORDER="2 "/>
   <source>method SET_ROOT.

  DATA:
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-set_root = abap_false.

*   &gt;
    _set_root( root ).
    me-&gt;root = root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        _set_root( root ).
        me-&gt;root = root.
*       &lt;
        _trace_service-&gt;trin_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_MONITOR_AREA" VERSION="1" LANGU="E" DESCRIPT="Area definition for the PRC parallel processes" CATEGORY="45" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="S" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CL_SHM_AREA">
  <friends CLSNAME="ZCL_PRC_MONITOR_AREA" REFCLSNAME="CL_SHM_AREA" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class

DEFINE mc_set_shm_client.

  if client is supplied.
    l_client = client.
    l_client_supplied = abap_true.
  else.
    l_client = cl_abap_syst=&gt;get_client( ).
  endif.

END-OF-DEFINITION.

DEFINE mc_set_shm_client_attach_only.

  l_client = cl_abap_syst=&gt;get_client( ).

END-OF-DEFINITION.</localMacros>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="AREA_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of an Area Class" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="&apos;ZCL_PRC_MONITOR_AREA&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_AREA_NAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ROOT" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of a Data Class" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_PRC_MONITOR_ACCESS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="_CLIENT_DEPENDENT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="2" ATTVALUE="ABAP_TRUE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="_LIFE_CONTEXT" VERSION="1" LANGU="E" DESCRIPT="Lifetime of an Area (Constants in CL_SHM_AREA)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="2" ATTVALUE="CL_SHM_AREA=&gt;LIFE_CONTEXT_APPSERVER" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SHM_LIFE_CONTEXT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="_TRACE_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="(Internal) Flag: Trace Active?" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="_TRACE_SERVICE" VERSION="1" LANGU="E" DESCRIPT="(Internal) Reference to Trace Class" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="IF_SHM_TRACE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="_TRANSACTIONAL" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="2" ATTVALUE="ABAP_FALSE" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_BOOL" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="_VERSION_" VERSION="1" LANGU="E" DESCRIPT="(internal)" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTVALUE="20" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_PRC_MONITOR_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_PRC_MONITOR_AREA" REFCLSNAME="CL_SHM_AREA" VERSION="1" MTDNAME="GET_ROOT" EXPOSURE="0"/>
  </inheritance>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" VERSION="1" LANGU="E" DESCRIPT="Request a Read Lock" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="HANDLE" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_MONITOR_AREA"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="E" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="E" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_READ_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Request for a Second Read Lock" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_READ" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="A Change Lock Is Already Active" MTDTYPE="0" EDITORDER="6 "/>
   <source>method ATTACH_FOR_READ.

  DATA:
    l_attributes       TYPE shma_attributes,
    l_root             TYPE REF TO object,
    l_cx               TYPE REF TO cx_root,
    l_client           TYPE shm_client,
    l_client_supplied  TYPE abap_bool. &quot;#EC NEEDED

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.

  mc_set_shm_client_attach_only.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_read = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

*   try sneak mode first
    handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                      sneak_mode   = abap_true
                                      life_context = _life_context
                            IMPORTING root         = l_root ).

    IF l_root IS INITIAL.
*     no root object returned, sneak mode was not successful.
*     -&gt; read area properties from database and try again.
      cl_shm_service=&gt;initialize(
        EXPORTING area_name       = handle-&gt;area_name
                  client          = l_client
        IMPORTING attributes      = l_attributes
      ).

      handle-&gt;properties = l_attributes-properties.
      handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                        sneak_mode   = abap_false
                                        life_context = _life_context
                              IMPORTING root         = l_root ).

    ENDIF.

    handle-&gt;root ?= l_root.
*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                          sneak_mode   = abap_true
                                          life_context = _life_context
                                IMPORTING root         = l_root ).

        IF l_root IS INITIAL.
*         no root object returned, sneak mode was not successful.
*         -&gt; read area properties from database and try again.
          cl_shm_service=&gt;initialize(
            EXPORTING area_name       = handle-&gt;area_name
                      client          = l_client
            IMPORTING attributes      = l_attributes
          ).

          handle-&gt;properties = l_attributes-properties.
          handle-&gt;_attach_read71( EXPORTING area_name    = area_name
                                            sneak_mode   = abap_false
                                            life_context = _life_context
                                  IMPORTING root         = l_root ).

        ENDIF.
        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_read(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" VERSION="1" LANGU="E" DESCRIPT="Request a Change Lock" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="E" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="WAIT_TIME" VERSION="1" LANGU="E" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="HANDLE" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_MONITOR_AREA"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_INCONSISTENT" VERSION="1" LANGU="E" DESCRIPT="Different Definitions Between Program and Area" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_NO_ACTIVE_VERSION" VERSION="1" LANGU="E" DESCRIPT="No active version exists for an attach" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="E" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="5 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="6 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_UPDATE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="E" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="7 "/>
   <source>method ATTACH_FOR_UPDATE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_root                   TYPE REF TO object,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.

  mc_set_shm_client_attach_only.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_upd = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_update70(
      EXPORTING area_name = handle-&gt;area_name
                mode      = attach_mode
      IMPORTING root      = l_root
      CHANGING  wait_time = l_wait_time ).

    IF abap_true = l_attributes-properties-has_versions AND
       handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
      handle-&gt;_attach_update70(
        EXPORTING area_name = handle-&gt;area_name
                  mode      = attach_mode
        IMPORTING root      = l_root
        CHANGING  wait_time = l_wait_time ).
    ENDIF.

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

      ENDWHILE.

    ENDIF.

    handle-&gt;root ?= l_root.

*   &lt;

  ELSE.

    TRY.

*       &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_update70(
          EXPORTING area_name = handle-&gt;area_name
                    mode      = attach_mode
          IMPORTING root      = l_root
          CHANGING  wait_time = l_wait_time ).

        IF abap_true = l_attributes-properties-has_versions AND
           handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
          handle-&gt;_attach_update70(
            EXPORTING area_name = handle-&gt;area_name
                      mode      = attach_mode
            IMPORTING root      = l_root
            CHANGING  wait_time = l_wait_time ).
        ENDIF.

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_update70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              IMPORTING
                root      = l_root
              CHANGING
                wait_time = l_wait_time ).

            IF abap_true = l_attributes-properties-has_versions AND
               handle-&gt;_lock IS NOT INITIAL.
* we may need a second try in case of class constructors
              handle-&gt;_attach_update70(
                EXPORTING
                  area_name = handle-&gt;area_name
                  mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
                IMPORTING
                  root      = l_root
                CHANGING
                  wait_time = l_wait_time ).
            ENDIF.

          ENDWHILE.

        ENDIF.

        handle-&gt;root ?= l_root.

*       &lt;
        _trace_service-&gt;trin_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_update(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" VERSION="1" LANGU="E" DESCRIPT="Request a Write Lock" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="ATTACH_MODE" VERSION="1" LANGU="E" DESCRIPT="Mode of ATTACH (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_ATTACH_MODE" PARVALUE="CL_SHM_AREA=&gt;ATTACH_MODE_DEFAULT"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="WAIT_TIME" VERSION="1" LANGU="E" DESCRIPT="Maximum Wait Time (in Milliseconds)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="0"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="HANDLE" VERSION="1" LANGU="E" DESCRIPT="SHM: Model of an Area Class" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_PRC_MONITOR_AREA"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_EXCLUSIVE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="Instance Already Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_VERSION_LIMIT_EXCEEDED" VERSION="1" LANGU="E" DESCRIPT="No Additional Versions Available" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_CHANGE_LOCK_ACTIVE" VERSION="1" LANGU="E" DESCRIPT="A write lock is already active" MTDTYPE="0" EDITORDER="3 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Passed Parameter Has Incorrect Value" MTDTYPE="0" EDITORDER="4 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="ATTACH_FOR_WRITE" SCONAME="CX_SHM_PENDING_LOCK_REMOVED" VERSION="1" LANGU="E" DESCRIPT="Shared Objects: Waiting Lock Was Deleted" MTDTYPE="0" EDITORDER="5 "/>
   <source>method ATTACH_FOR_WRITE.

  DATA:
    l_attributes             TYPE shma_attributes,
    l_cx                     TYPE REF TO cx_root,
    l_client                 TYPE shm_client,
    l_client_supplied        TYPE abap_bool, &quot;#EC NEEDED
    l_wait_time              TYPE i,
    l_wait_time_per_loop     TYPE i,
    l_wait_time_per_loop_sec TYPE f.

  l_wait_time = wait_time.

* check if tracing should be activated/de-activated
  IF  ( NOT _trace_service IS INITIAL ).
    TRY.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      CATCH cx_root. &quot;#EC NO_HANDLER
                     &quot;#EC CATCH_ALL
    ENDTRY.
  ENDIF.

  mc_set_shm_client_attach_only.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-attach_for_write = abap_false.

*   &gt;

    CREATE OBJECT handle.

    handle-&gt;client    = l_client.
    handle-&gt;inst_name = inst_name.

    cl_shm_service=&gt;initialize(
      EXPORTING area_name    = handle-&gt;area_name
                client       = l_client
      IMPORTING attributes   = l_attributes
    ).

    handle-&gt;properties = l_attributes-properties.

    handle-&gt;_attach_write70(
      EXPORTING
        area_name = handle-&gt;area_name
        mode      = attach_mode
      CHANGING
        wait_time = l_wait_time ).

    IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
       handle-&gt;_lock IS INITIAL.

      l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
      IF l_wait_time_per_loop &lt; 2000.
        l_wait_time_per_loop = 2000.
      ELSEIF l_wait_time_per_loop &gt; 300000.
        l_wait_time_per_loop = 300000.
      ENDIF.

      l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

      WHILE handle-&gt;_lock IS INITIAL.

        IF l_wait_time_per_loop &gt; l_wait_time.
          l_wait_time_per_loop = l_wait_time.
          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
        ENDIF.

        WAIT UP TO l_wait_time_per_loop_sec SECONDS.
        l_wait_time = l_wait_time - l_wait_time_per_loop.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
          CHANGING
            wait_time = l_wait_time ).

      ENDWHILE.

    ENDIF.

*   &lt;

  ELSE.

    TRY.

*     &gt;

        CREATE OBJECT handle.

        handle-&gt;client    = l_client.
        handle-&gt;inst_name = inst_name.

        cl_shm_service=&gt;initialize(
          EXPORTING area_name    = handle-&gt;area_name
                    client       = l_client
          IMPORTING attributes   = l_attributes
        ).

        handle-&gt;properties = l_attributes-properties.

        handle-&gt;_attach_write70(
          EXPORTING
            area_name = handle-&gt;area_name
            mode      = attach_mode
          CHANGING
            wait_time = l_wait_time ).

        IF attach_mode = cl_shm_area=&gt;attach_mode_wait AND
           handle-&gt;_lock IS INITIAL.

          l_wait_time_per_loop = l_wait_time / 10.
* wait_time_per_loop should be at least 2 * SHMATTACHWRITE_MAXACTIVEWAIT
          IF l_wait_time_per_loop &lt; 2000.
            l_wait_time_per_loop = 2000.
          ELSEIF l_wait_time_per_loop &gt; 300000.
            l_wait_time_per_loop = 300000.
          ENDIF.

          l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.

          WHILE handle-&gt;_lock IS INITIAL.

            IF l_wait_time_per_loop &gt; l_wait_time.
              l_wait_time_per_loop = l_wait_time.
              l_wait_time_per_loop_sec = l_wait_time_per_loop / 1000.
            ENDIF.

            WAIT UP TO l_wait_time_per_loop_sec SECONDS.
            l_wait_time = l_wait_time - l_wait_time_per_loop.

            handle-&gt;_attach_write70(
              EXPORTING
                area_name = handle-&gt;area_name
                mode      = cl_shm_area=&gt;attach_mode_wait_2nd_try
              CHANGING
                wait_time = l_wait_time ).

          ENDWHILE.

        ENDIF.

*     &lt;

        _trace_service-&gt;trin_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
        ).
      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_attach_for_write(
          area_name = area_name
          inst_name = inst_name
          client    = l_client
          mode      = attach_mode
          wait_time = wait_time
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

  handle-&gt;inst_trace_service = _trace_service.
  handle-&gt;inst_trace_active  = _trace_active.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="BUILD" VERSION="1" LANGU="E" DESCRIPT="Direct Call of Area Constructor" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="BUILD" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_NOT_CONFIGURED" VERSION="1" LANGU="E" DESCRIPT="SHM Administration: Area Property Is Not Configured" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="BUILD" SCONAME="CX_SHMA_INCONSISTENT" VERSION="1" LANGU="E" DESCRIPT="SHM Administration: Inconsistent Attribute Combination" MTDTYPE="0" EDITORDER="2 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="BUILD" SCONAME="CX_SHM_BUILD_FAILED" VERSION="1" LANGU="E" DESCRIPT="Constructor Run Failed" MTDTYPE="0" EDITORDER="3 "/>
   <source>method BUILD.

  DATA:
    l_cls_name TYPE shm_auto_build_class_name,
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-build = abap_false.

*   &gt;
    l_cls_name =
      cl_shm_service=&gt;get_auto_build_class_name( area_name ).

    CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
      EXPORTING
        inst_name = inst_name.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        l_cls_name =
          cl_shm_service=&gt;get_auto_build_class_name( area_name ).

        CALL METHOD (l_cls_name)=&gt;if_shm_build_instance~build
          EXPORTING
            inst_name = inst_name.
*       &lt;
        _trace_service-&gt;trin_build(
          area_name         = area_name
          inst_name         = inst_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_build(
          area_name         = area_name
          inst_name         = inst_name
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.

* TRACE { DO NOT REMOVE THIS LINE !
  _trace_active = abap_false.
  TRY.
      _trace_service =
        cl_shm_service=&gt;trace_get_service( area_name ).
      IF NOT _trace_service IS INITIAL.
        _trace_active =
          cl_shm_service=&gt;trace_is_variant_active(
            _trace_service-&gt;variant-def_name
          ).
      ENDIF.
    CATCH cx_root. &quot;#EC NO_HANDLER
                   &quot;#EC CATCH_ALL
  ENDTRY.
* TRACE } DO NOT REMOVE THIS LINE !

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="DETACH_AREA" VERSION="1" LANGU="E" DESCRIPT="Release all locks on all instances" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="DETACH_AREA" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="DETACH_AREA" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <source>method DETACH_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  mc_set_shm_client.

* &gt;
  rc = _detach_area71( area_name        = area_name
                       client           = l_client
                       client_supplied  = l_client_supplied
                       client_dependent = _client_dependent
                       life_context     = _life_context
       ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-detach_area = abap_true.
      _trace_service-&gt;trin_detach_area(
        area_name = area_name
        client    = l_client
        rc        = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_AREA" VERSION="1" LANGU="E" DESCRIPT="Delete all instances" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_AREA" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_AREA" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _free_area71( area_name         = area_name
                     client            = l_client
                     client_supplied   = l_client_supplied
                     client_dependent  = _client_dependent
                     transactional     = _transactional
                     terminate_changer = terminate_changer
                     affect_server     = affect_server
                     life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_area = abap_true.
      _trace_service-&gt;trin_free_area(
      area_name         = area_name
      client            = l_client
      terminate_changer = terminate_changer
      affect_server     = affect_server
      rc                = rc
    ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Deletion of an Instance" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="FREE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method FREE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _free_instance71( area_name         = area_name
                         inst_name         = inst_name
                         client            = l_client
                         client_supplied   = l_client_supplied
                         client_dependent  = _client_dependent
                         transactional     = _transactional
                         terminate_changer = terminate_changer
                         affect_server     = affect_server
                         life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-free_instance = abap_true.
      _trace_service-&gt;trin_free_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="GET_GENERATOR_VERSION" VERSION="1" LANGU="E" DESCRIPT="Query Generator Version" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="GET_GENERATOR_VERSION" SCONAME="GENERATOR_VERSION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method GET_GENERATOR_VERSION.
  generator_version = _version_.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="GET_INSTANCE_INFOS" VERSION="1" LANGU="E" DESCRIPT="Returns the names of all instances" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance in an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="GET_INSTANCE_INFOS" SCONAME="INFOS" VERSION="1" LANGU="E" DESCRIPT="Overview of all Instances of an SHM Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_INST_INFOS"/>
   <source>method GET_INSTANCE_INFOS.

  DATA:
    l_client             TYPE shm_client,
    l_client_supplied    TYPE abap_bool VALUE abap_false,
    l_inst_name_supplied TYPE abap_bool VALUE abap_false.

  mc_set_shm_client.

  IF inst_name IS SUPPLIED.
    l_inst_name_supplied = abap_true.
  ENDIF.

* &gt;
  TRY.
      CALL METHOD (&apos;_GET_INSTANCE_INFOS804&apos;)
        EXPORTING
          area_name          = area_name
          client             = l_client
          client_supplied    = l_client_supplied
          client_dependent   = _client_dependent
          life_context       = _life_context
          inst_name          = inst_name
          inst_name_supplied = l_inst_name_supplied
        RECEIVING
          infos              = infos.
    CATCH cx_sy_dyn_call_illegal_method.
*     New kernel and/or new basis SP missing -&gt; use slow fallback
      infos = _get_instance_infos71(
                area_name        = area_name
                client           = l_client
                client_supplied  = l_client_supplied
                client_dependent = _client_dependent
                life_context     = _life_context
              ).
      IF abap_true = l_inst_name_supplied.
        DELETE infos WHERE name &lt;&gt; inst_name.
      ENDIF.
  ENDTRY.
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-get_instance_inf = abap_true.
      _trace_service-&gt;trin_get_instance_infos(
        area_name         = area_name
        client            = l_client
        infos             = infos
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="CL_SHM_AREA" CMPNAME="GET_ROOT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method GET_ROOT.

  DATA:
    l_cx        TYPE REF TO cx_root,
    l_area_name TYPE string,
    l_inst_name TYPE string,
    l_client    TYPE string.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-get_root = abap_false.

*   &gt;
    IF is_valid( ) = abap_false.
      l_area_name = me-&gt;area_name.
      l_inst_name = me-&gt;inst_name.
      l_client    = me-&gt;client.
      RAISE EXCEPTION TYPE cx_shm_already_detached
        EXPORTING
          area_name = l_area_name
          inst_name = l_inst_name
          client    = l_client.
    ENDIF.
    root = me-&gt;root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        IF is_valid( ) = abap_false.
          l_area_name = me-&gt;area_name.
          l_inst_name = me-&gt;inst_name.
          l_client    = me-&gt;client.
          RAISE EXCEPTION TYPE cx_shm_already_detached
            EXPORTING
              area_name = l_area_name
              inst_name = l_inst_name
              client    = l_client.
        ENDIF.
        root = me-&gt;root.
*       &lt;

        _trace_service-&gt;trin_get_root(
          area_name = area_name
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_get_root(
          area_name = area_name
          cx        = l_cx
        ).
    ENDTRY.

  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_AREA" VERSION="1" LANGU="E" DESCRIPT="Active versions of all instances will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_AREA" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_AREA.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool VALUE abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _invalidate_area71( area_name         = area_name
                           client            = l_client
                           client_supplied   = l_client_supplied
                           client_dependent  = _client_dependent
                           transactional     = _transactional
                           terminate_changer = terminate_changer
                           affect_server     = affect_server
                           life_context      = _life_context ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_area = abap_true.
      _trace_service-&gt;trin_invalidate_area(
        area_name         = area_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Active version of one instance will be set to obsolete" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CLIENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_CLIENT" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="INST_NAME" VERSION="1" LANGU="E" DESCRIPT="Name of a Shared Object Instance of an Area" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SHM_INST_NAME" PARVALUE="CL_SHM_AREA=&gt;DEFAULT_INSTANCE" PAROPTIONL="X" PARPREFERD="X"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="TERMINATE_CHANGER" VERSION="1" LANGU="E" DESCRIPT="Active writing processes will be ended" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="RC" VERSION="1" LANGU="E" DESCRIPT="Detach Return Value (Constants in CL_SHM_AREA)" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SHM_RC"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="INVALIDATE_INSTANCE" SCONAME="CX_SHM_PARAMETER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Incorrect parameter transferred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INVALIDATE_INSTANCE.

  DATA:
    l_client TYPE shm_client,
    l_client_supplied TYPE abap_bool value abap_false.

  CONSTANTS: affect_server TYPE shm_affect_server
             VALUE cl_shm_area=&gt;affect_local_server.

  mc_set_shm_client.

* &gt;
  rc = _invalidate_instance71(
    area_name         = area_name
    inst_name         = inst_name
    client            = l_client
    client_supplied   = l_client_supplied
    client_dependent  = _client_dependent
    transactional     = _transactional
    terminate_changer = terminate_changer
    affect_server     = affect_server
    life_context      = _life_context
  ).
* &lt;

  IF _trace_active = abap_true.
    IF _trace_service-&gt;variant-invalidate_inst = abap_true.
      _trace_service-&gt;trin_invalidate_instance(
        area_name         = area_name
        inst_name         = inst_name
        client            = l_client
        terminate_changer = terminate_changer
        affect_server     = affect_server
        rc                = rc
      ).
    ENDIF.
  ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="SET_ROOT" VERSION="1" LANGU="E" DESCRIPT="Sets Root Objects" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="SET_ROOT" SCONAME="ROOT" VERSION="1" LANGU="E" DESCRIPT="Root object" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_PRC_MONITOR_ACCESS"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_INITIAL_REFERENCE" VERSION="1" LANGU="E" DESCRIPT="Initial Reference Passed" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_MONITOR_AREA" CMPNAME="SET_ROOT" SCONAME="CX_SHM_WRONG_HANDLE" VERSION="1" LANGU="E" DESCRIPT="Incorrect Handle" MTDTYPE="0" EDITORDER="2 "/>
   <source>method SET_ROOT.

  DATA:
    l_cx TYPE REF TO cx_root.

  IF _trace_active = abap_false OR
  _trace_service-&gt;variant-set_root = abap_false.

*   &gt;
    _set_root( root ).
    me-&gt;root = root.
*   &lt;

  ELSE.

    TRY.

*       &gt;
        _set_root( root ).
        me-&gt;root = root.
*       &lt;
        _trace_service-&gt;trin_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
        ).

      CLEANUP INTO l_cx.
        _trace_service-&gt;trcx_set_root(
          area_name         = area_name
          inst_name         = inst_name
          root              = root
          cx                = l_cx
        ).
    ENDTRY.

  ENDIF.

endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_MONITOR_ACCESS" VERSION="1" LANGU="E" DESCRIPT="PRC Process Monitor(in shared memory)" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" CLSSHAREDMEMORY="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="REGISTRATION" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="26 " TYPESRC_LENG="178 " TYPESRC="begin of registration,
          pid type char8,
          uname like sy-uname,
          wp_id type char8,
          mod_time type timestampl,
        end of registration
"/>
  <types CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="COUNT_ENTRY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="17 " SRCCOLUMN2="25 " TYPESRC_LENG="139 " TYPESRC="begin of count_entry,
          uname like sy-uname,
          wp_max type i,
          wp_counter type i,
        end of count_entry
"/>
  <friends CLSNAME="ZCL_PRC_MONITOR_ACCESS" REFCLSNAME="ZCL_PRC_MONITOR" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <friends CLSNAME="ZCL_PRC_MONITOR_ACCESS" REFCLSNAME="ZCL_PRC_MONITOR_BUILDER" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_PRC_MONITOR_ACCESS" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_PRC_MONITOR_ACCESS" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="MT_AVAIL_PIDS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="23 " SRCCOLUMN1="4 " SRCROW2="23 " SRCCOLUMN2="41 " TYPESRC_LENG="40 " TYPESRC="mt_avail_pids type standard table of i
"/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="MT_REGISTER" VERSION="1" LANGU="E" DESCRIPT="Process Register" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="21 " SRCCOLUMN2="68 " TYPESRC_LENG="67 " TYPESRC="mt_register type sorted table of registration with unique key pid
"/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="MT_WP_COUNT" VERSION="1" LANGU="E" DESCRIPT="Work Process Count" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="25 " SRCCOLUMN1="4 " SRCROW2="25 " SRCCOLUMN2="69 " TYPESRC_LENG="68 " TYPESRC="mt_wp_count type hashed table of count_entry with unique key uname
"/>
  <attribute CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="MV_PROCESS_COUNT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="ATTACH_WP" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="ATTACH_WP" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method attach_wp.
    field-symbols: &lt;fs_register&gt; like line of mt_register.

    read table mt_register with table key pid = iv_pid assigning &lt;fs_register&gt;.
    &lt;fs_register&gt;-wp_id = get_wp_id( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method constructor.
    data: lv_count type i value 1,
          lv_pid type num8.

    &quot;... Setup a buffer of PIDS
    do 10000 times.
      lv_pid = lv_count.
      append lv_pid to mt_avail_pids.

      lv_count = lv_count + 1.
    enddo.

    mv_process_count = mv_process_count + 1000.
  endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="DEREGISTER_PID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="DEREGISTER_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method deregister_pid.
    delete table mt_register with table key pid = iv_pid.
*    delete table mt_register with table key pid = iv_pid wp_id = get_wp_id( ).
    set_wp_avail( get_wp_avail( ) + 1 ).

    &quot;... Push the PID back as an available id
    push_pid( iv_pid ).

  endmethod.                    &quot;DEREGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GARBAGE_COLLECT" VERSION="1" LANGU="E" DESCRIPT="Clean up any WP IDs that have been reallocated" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GARBAGE_COLLECT" SCONAME="IV_BYPASS_LONGCHK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
   <source>method garbage_collect.
    data: lt_wpinfo type standard table of wpinfo,
          ls_wpinfo type wpinfo,
          ls_register like line of mt_register,
          lt_pids type standard table of char8,
          lv_check type abap_bool,
          lv_pid type char8.

    if get_wp_avail( ) eq 0 or iv_bypass_longchk eq abap_true.
      lv_check = abap_true.
    elseif has_long_process( ) eq abap_true.
      lv_check = abap_true.
    endif.

    if lv_check eq abap_true.
      call function &apos;TH_WPINFO&apos;
        tables
          wplist     = lt_wpinfo
        exceptions
          send_error = 1
          others     = 2.

      loop at mt_register into ls_register where uname eq sy-uname.
        if ls_register-wp_id is initial.
          continue.
        endif.
        read table lt_wpinfo with key wp_bname = sy-uname wp_pid = ls_register-wp_id into ls_wpinfo.
        if sy-subrc ne 0.
          append ls_register-pid to lt_pids.
        endif.
      endloop.
      loop at lt_pids into lv_pid.
        deregister_pid( lv_pid ).
      endloop.
    endif.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GET_WP_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Number of parallel processes avail for user / session id" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GET_WP_AVAIL" SCONAME="RV_WP_AVAIL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method get_wp_avail.
  data: ls_count_entry type count_entry.

  read table mt_wp_count with table key uname = sy-uname into ls_count_entry.

  &quot;... User has a count return it
  if sy-subrc eq 0.
    rv_wp_avail = ls_count_entry-wp_counter.
  else.
    &quot;... If no count avail return a -1 to indicate so it can be initialised via change lock
    rv_wp_avail = -1.
  endif.
endmethod.                    &quot;GET_WP_AVAIL</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GET_WP_ID" VERSION="1" LANGU="E" DESCRIPT="Get the current WP ID" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GET_WP_ID" SCONAME="RV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method get_wp_id.
    &quot;... Get the PID for the current work process
    call function &apos;TH_GET_OWN_WP_NO&apos;
      importing
        wp_pid   = rv_pid.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GET_WP_MAX" VERSION="1" LANGU="E" DESCRIPT="Maximum parallel processes for user / session id" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="GET_WP_MAX" SCONAME="RV_WP_MAX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
   <source>method get_wp_max.
    data: ls_count_entry type count_entry.
    read table mt_wp_count with table key uname = sy-uname into ls_count_entry.

    &quot;... User has a max set return it
    if sy-subrc eq 0.
      rv_wp_max = ls_count_entry-wp_max.
    else.
      &quot;... no max so we will set one up()
      number_of_processes( zcl_prc_wp_manager=&gt;get_max_work_processes( ) ).
    endif.
  endmethod.                    &quot;GET_WP_MAX</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="HAS_LONG_PROCESS" VERSION="1" LANGU="E" DESCRIPT="Check if a very long process is registered" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="HAS_LONG_PROCESS" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_long_process.
    data: ls_register like line of mt_register,
          lv_time type timestampl,
          lv_secs type tzntstmpl.

    &quot;... Get current time
    get time stamp field lv_time.

    loop at mt_register into ls_register where uname = sy-uname.
      lv_secs = cl_abap_tstmp=&gt;subtract( tstmp1 = lv_time
                                         tstmp2 = ls_register-mod_time ).
      if lv_secs gt 120.
        rv_result = abap_true.
        return.
      endif.
    endloop.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="HAS_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Check if processes exist(by username)" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="HAS_PROCESSES" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method has_processes.
  read table mt_register with key uname = sy-uname transporting no fields.
  case sy-subrc.
    when 0.
      rv_result = abap_true.
  endcase.
endmethod.                    &quot;has_processes</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="INCREASE_PID_BUFFER" VERSION="1" LANGU="E" DESCRIPT="Increase the buffer of available PIDS" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="INCREASE_PID_BUFFER" SCONAME="IV_THRESHHOLD" VERSION="1" LANGU="E" DESCRIPT="How many more to generate" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method increase_pid_buffer.
  endmethod.                    &quot;INCREASE_PID_BUFFER</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="NUMBER_OF_PROCESSES" VERSION="1" LANGU="E" DESCRIPT="Set the number of processes to use" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="NUMBER_OF_PROCESSES" SCONAME="IV_NUM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method number_of_processes.
    data: lv_chk type i,
          ls_count_entry type count_entry.
    field-symbols: &lt;fs_count_entry&gt; type count_entry.
    read table mt_wp_count with table key uname = sy-uname assigning &lt;fs_count_entry&gt;.

    if sy-subrc eq 0.
      if iv_num ne &lt;fs_count_entry&gt;-wp_max.
        lv_chk = iv_num - ( &lt;fs_count_entry&gt;-wp_max - &lt;fs_count_entry&gt;-wp_counter ).

        if lv_chk ge 0.
          &lt;fs_count_entry&gt;-wp_counter = lv_chk.
        else.
          &lt;fs_count_entry&gt;-wp_counter = 0.
        endif.
      endif.
      &lt;fs_count_entry&gt;-wp_max = iv_num.
    else.
      ls_count_entry-uname = sy-uname.
      ls_count_entry-wp_max = iv_num.
      ls_count_entry-wp_counter = iv_num.
      insert ls_count_entry into table mt_wp_count.
    endif.

  endmethod.                    &quot;NUMBER_OF_PROCESSES</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="PID_EXISTS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="PID_EXISTS" SCONAME="IV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="PID_EXISTS" SCONAME="RV_EXISTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method pid_exists.
    read table mt_register with table key pid = iv_pid transporting no fields.
*    read table mt_register with table key pid = iv_pid wp_id = get_wp_id( ) transporting no fields.

    case sy-subrc.
      when 0.
        rv_exists = abap_true.
    endcase.
  endmethod.                    &quot;PID_EXISTS</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="POP_PID" VERSION="1" LANGU="E" DESCRIPT="Pop the next PID off the list" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="POP_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method pop_pid.
    data: lv_num type num8.
    read table mt_avail_pids into lv_num index 1.
    delete mt_avail_pids index 1.
    rv_pid = lv_num.
  endmethod.                    &quot;POP_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="PUSH_PID" VERSION="1" LANGU="E" DESCRIPT="Push a PID back onto the available list" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="PUSH_PID" SCONAME="IV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <source>method push_pid.
    data: lv_pid type i.
    lv_pid = iv_pid.
    append lv_pid to mt_avail_pids.
  endmethod.                    &quot;PUSH_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="REGISTER_PID" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="REGISTER_PID" SCONAME="RV_PID" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR8"/>
   <exception CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="REGISTER_PID" SCONAME="ZCX_PRC_NO_PROCESSES_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Raised when no proceses available for user" MTDTYPE="0" EDITORDER="1 "/>
   <source>method register_pid.
    data: lv_num type num8,
          lv_wp_avail type i,
          ls_register type registration.

    lv_wp_avail = get_wp_avail( ).
    if lv_wp_avail eq 0.
      raise exception type zcx_prc_no_processes_avail.
    endif.

    &quot;... Get the next available PID
    rv_pid = pop_pid( ).

    ls_register-pid = rv_pid.
    ls_register-uname = sy-uname.
    get time stamp field ls_register-mod_time.
    insert ls_register into table mt_register.
    set_wp_avail( lv_wp_avail - 1 ).
  endmethod.                    &quot;REGISTER_PID</source>
  </method>
  <method CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="SET_WP_AVAIL" VERSION="1" LANGU="E" DESCRIPT="Set the current wp count for user / session id" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_MONITOR_ACCESS" CMPNAME="SET_WP_AVAIL" SCONAME="IV_WP_AVAIL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <source>method set_wp_avail.
    field-symbols: &lt;fs_count_entry&gt; type count_entry.
    read table mt_wp_count with table key uname = sy-uname assigning &lt;fs_count_entry&gt;.

    &quot;... This is a major explosion if its ne 0
    if sy-subrc ne 0.
      raise exception type zcx_prc_process_exception.
    else.
      &lt;fs_count_entry&gt;-wp_counter = iv_wp_avail.
    endif.
  endmethod.                    &quot;SET_WP_AVAIL</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_BARRIER" VERSION="1" LANGU="E" DESCRIPT="Wait for a PRC Processes to complete (Processes only)" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <method CLSNAME="ZCL_PRC_BARRIER" CMPNAME="WAIT" VERSION="1" LANGU="E" DESCRIPT="Wait for PRC threads" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_BARRIER" CMPNAME="WAIT" SCONAME="IV_TIMEOUT" VERSION="1" LANGU="E" DESCRIPT="Timeout in Seconds" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="86400"/>
   <exception CLSNAME="ZCL_PRC_BARRIER" CMPNAME="WAIT" SCONAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Timeout when waiting occurred" MTDTYPE="0" EDITORDER="1 "/>
   <source>method wait.
  data lv_time type t.
  &quot;... Even if this times out there is no guarantee the processes
  &quot;... executing wont just finish what they are doing
  get time field lv_time.
  while zcl_prc_monitor=&gt;has_processes( ) eq abap_true.
    get time.
    if ( ( sy-uzeit - lv_time ) mod 86400 ) gt iv_timeout.
      raise exception type zcx_prc_wait_timout_exception.
    endif.
  endwhile.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_PRC_NO_RETURN_TYPE_SET" VERSION="1" LANGU="E" DESCRIPT="No Return type set for the Callable" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_PRC_NO_RETURN_TYPE_SET" REFCLSNAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_BACKGROUND_JOB" VERSION="1" LANGU="E" DESCRIPT="Runs as a Background Job(e.g. a job is submitted internally)" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_PRC_BACKGROUND_JOB" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations
class lcl_processor definition.
  public section.
    methods:
      constructor
        importing ir_process type ref to zcl_prc_background_job,
      dispatch
        importing iv_uname type sy-uname default sy-uname
        raising zcx_prc_process_exception zcx_prc_wait_timout_exception.
  protected section.
  private section.
    data: mr_process type ref to zcl_prc_background_job.
    methods:
      serialize returning value(rv_process) type zprce_data.
endclass.                    &quot;lcl_processor DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_processor IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class lcl_processor implementation.
  method constructor.
    mr_process = ir_process.
  endmethod.                    &quot;constructor

  method serialize.
    call transformation id_indent
     source obj = mr_process
     result xml rv_process.
  endmethod.                    &quot;serialize
  method dispatch.
    data: ls_bg type zprcd_background,
          lv_count type btcjobcnt,
          lv_job type btcjob value &apos;Z_PRC_BACKGROUND_JOB&apos;,
          lv_released type btcchar1,
          lv_group type bpsrvgrp,
          lv_priority type btcjobclas value &apos;B&apos;,
          lv_time type t.

    get time field lv_time.

    &quot;... Set the guid
    mr_process-&gt;mv_guid = cl_system_uuid=&gt;create_uuid_x16_static( ).
    lv_group = mr_process-&gt;mv_group.

    &quot;... Get the serialized data
    ls_bg-data = serialize( ).
    ls_bg-guid = mr_process-&gt;mv_guid.
    get time stamp field ls_bg-time.

    if mr_process-&gt;mr_schedule is not initial.
      lv_job = mr_process-&gt;mr_schedule-&gt;jobname( ).
      lv_priority = mr_process-&gt;mr_schedule-&gt;priority( ).
    endif.

    call function &apos;JOB_OPEN&apos;
      exporting
        jobname          = lv_job
        jobclass         = lv_priority
      importing
        jobcount         = lv_count
      exceptions
        cant_create_job  = 1
        invalid_job_data = 2
        jobname_missing  = 3
        others           = 4.
    if sy-subrc &lt;&gt; 0.
      raise exception type zcx_prc_process_failed.
    endif.

    &quot;... The program will use this table entry
    modify zprcd_background from ls_bg.

    &quot;... Submit the job
    submit z_prc_background_job with guid = mr_process-&gt;mv_guid
                    with delay = mr_process-&gt;mv_delay
                    user sy-uname
                    via job lv_job number lv_count and return.
    if sy-subrc ne 0.
      delete zprcd_background from ls_bg.
      commit work. &quot;... This must happen
      raise exception type zcx_prc_process_failed.
    endif.
    if mr_process-&gt;mr_schedule is initial.
      &quot;... No schedule, start immediately
      call function &apos;JOB_CLOSE&apos;
        exporting
          jobcount             = lv_count
          jobname              = lv_job
          strtimmed            = &apos;X&apos;
          targetgroup          = lv_group
        importing
          job_was_released     = lv_released
        exceptions
          cant_start_immediate = 1
          invalid_startdate    = 2
          jobname_missing      = 3
          job_close_failed     = 4
          job_nosteps          = 5
          job_notex            = 6
          lock_failed          = 7
          invalid_target       = 8
          others               = 9.
      if sy-subrc ne 0.
        delete zprcd_background from ls_bg.
        commit work. &quot;... This must happen
        raise exception type zcx_prc_process_failed.
      endif.
    else.
      &quot;... Use the schedule
      call function &apos;JOB_CLOSE&apos;
        exporting
          jobcount             = lv_count
          jobname              = lv_job
          sdlstrtdt            = mr_process-&gt;mr_schedule-&gt;date( )
          sdlstrttm            = mr_process-&gt;mr_schedule-&gt;time( )
          targetgroup          = lv_group
        importing
          job_was_released     = lv_released
        exceptions
          cant_start_immediate = 1
          invalid_startdate    = 2
          jobname_missing      = 3
          job_close_failed     = 4
          job_nosteps          = 5
          job_notex            = 6
          lock_failed          = 7
          invalid_target       = 8
          others               = 9.
      if sy-subrc ne 0.
        delete zprcd_background from ls_bg.
        commit work. &quot;... This must happen
        raise exception type zcx_prc_process_failed.
      endif.
    endif.

    &quot;... Commit
    commit work.
  endmethod.                   &quot;dispatch
endclass.                    &quot;lcl_processor IMPLEMENTATION</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section
class lcl_processor definition deferred.
class ZCL_PRC_BACKGROUND_job definition local friends lcl_processor.</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="MR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="MR_SCHEDULE" VERSION="1" LANGU="E" DESCRIPT="Used to add scheduling" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_PRC_JOB_SCHEDULE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="MV_DELAY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="MV_GROUP" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTVALUE="&apos; &apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="MV_GUID" VERSION="1" LANGU="E" DESCRIPT="16 Byte UUID in 16 Bytes (Raw Format)" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SYSUUID_X16" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="CONSTRUCTOR" SCONAME="IR_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_PRC_RUNNABLE"/>
   <parameter CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="CONSTRUCTOR" SCONAME="IV_DELAY" VERSION="1" LANGU="E" DESCRIPT="Seconds, yes as a char e.g. &apos;2&apos; or &apos;0.2&apos; dont ask" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <source>method CONSTRUCTOR.
  mr_runnable = ir_runnable.
  mv_delay = iv_delay.
endmethod.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="START" VERSION="1" LANGU="E" DESCRIPT="Start the process" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="START" SCONAME="SCHEDULE" VERSION="1" LANGU="E" DESCRIPT="Used to add scheduling" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_PRC_JOB_SCHEDULE" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="START" SCONAME="ZCX_PRC_PROCESS_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_BACKGROUND_JOB" CMPNAME="START" SCONAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="2 "/>
   <source>method start.
  data: lr_processor type ref to lcl_processor.

  mr_schedule = schedule.

  create object lr_processor
    exporting
      ir_process = me.

  lr_processor-&gt;dispatch( ).
endmethod.                    &quot;START</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_FUTURE_TASK" VERSION="1" LANGU="E" DESCRIPT="Runs as new task, results retrievable via shared memory mgr" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <friends CLSNAME="ZCL_PRC_FUTURE_TASK" REFCLSNAME="ZCL_PRC_FUTURE_EXECUTOR" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_PRC_FUTURE_TASK" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="MR_CALLABLE" VERSION="1" LANGU="E" DESCRIPT="Callback interface for definition of callback" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_PRC_CALLABLE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="MV_DELAY" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="CONSTRUCTOR" SCONAME="IR_CALLABLE" VERSION="1" LANGU="E" DESCRIPT="Callback interface for definition of callback" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_PRC_CALLABLE"/>
   <source>method CONSTRUCTOR.
  mr_callable = ir_callable.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="GET_RESULT" VERSION="1" LANGU="E" DESCRIPT="Get the result of the completion process" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="GET_RESULT" SCONAME="IV_TIMEOUT" VERSION="1" LANGU="E" DESCRIPT="Wait for completion Timeout in seconds" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PARVALUE="86400"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="GET_RESULT" SCONAME="RESULT" VERSION="1" LANGU="E" DESCRIPT="The result" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="GET_RESULT" SCONAME="ZCX_PRC_WAIT_TIMOUT_EXCEPTION" VERSION="1" LANGU="E" DESCRIPT="Timeout when waiting occurred" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="GET_RESULT" SCONAME="ZCX_PRC_PROCESS_FAILED" VERSION="1" LANGU="E" DESCRIPT="The process failed already during execution, check error tra" MTDTYPE="0" EDITORDER="2 "/>
   <source>method get_result.
  data: lv_time type t,
        lv_data type zprce_data,
        lr_data type ref to data.
  field-symbols: &lt;fs_any&gt; type any.

  &quot;... Even if this times out there is no guarantee the processes
  &quot;... executing wont just finish what they are doing
  get time field lv_time.

  try.
      while _is_complete( iv_pid = mr_callable-&gt;mv_cpid iv_guid = mr_callable-&gt;mv_guid ) eq abap_false.
        get time.
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt iv_timeout.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
      endwhile.
    catch zcx_prc_process_failed.
      raise exception type zcx_prc_process_failed.
  endtry.

  &quot;... Task is complete since we made it here, get the result
  lv_data = _get( ).

  &quot;... Check for initial, this should be impossible
  check lv_data is not initial.

  create data lr_data like result.
  assign lr_data-&gt;* to &lt;fs_any&gt;.

  &quot;... Deserialize the result
  zcl_prc_serialization_util=&gt;deserialize_result( exporting iv_data = lv_data
                                                  importing er_result = &lt;fs_any&gt; ).

  result = &lt;fs_any&gt;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_GARBAGE_COLLECT" VERSION="1" LANGU="E" DESCRIPT="Collect broken pids" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_GARBAGE_COLLECT" SCONAME="IV_BYPASS_LONGCHK" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
   <source>method _GARBAGE_COLLECT.
    data: lr_area type ref to zcl_prc_executor_area,
          lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

    get time field lv_time.
    do.
      try.
          lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
          exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
          get time.
          &quot;... 1hr Retry(pretty extreme)
          if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
            raise exception type zcx_prc_wait_timout_exception.
          endif.
      endtry.
    enddo.

    &quot;... Check for previous success
    check lr_area is not initial and lr_area-&gt;root is not initial.
    lr_executor = lr_area-&gt;root.

    lr_executor-&gt;garbage_collect( iv_bypass_longchk ).
    lr_area-&gt;detach_commit( ).
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_GET" VERSION="1" LANGU="E" DESCRIPT="Actually get the result" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_GET" SCONAME="RV_RESULT" VERSION="1" LANGU="E" DESCRIPT="PRC Data" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZPRCE_DATA"/>
   <source>method _GET.
  data: lr_area type ref to zcl_prc_executor_area,
        lr_executor type ref to zcl_prc_executor_access,
        lr_exc type ref to cx_shm_attach_error,
        lv_time type t.

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_executor_area=&gt;attach_for_update( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
        exit. &quot;... Exit Do
      catch cx_shm_exclusive_lock_active
            cx_shm_version_limit_exceeded
            cx_shm_change_lock_active
            cx_shm_read_lock_active
            cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_executor = lr_area-&gt;root.

  rv_result = lr_executor-&gt;get_result( mr_callable-&gt;mv_guid ).
  lr_area-&gt;detach_commit( ).
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_IS_COMPLETE" VERSION="1" LANGU="E" DESCRIPT="Check if completed yet" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_IS_COMPLETE" SCONAME="IV_PID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR8"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_IS_COMPLETE" SCONAME="IV_GUID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SYSUUID_X16"/>
   <parameter CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_IS_COMPLETE" SCONAME="RV_COMPLETE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <exception CLSNAME="ZCL_PRC_FUTURE_TASK" CMPNAME="_IS_COMPLETE" SCONAME="ZCX_PRC_PROCESS_FAILED" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method _IS_COMPLETE.
  data: lr_area type ref to zcl_prc_executor_area,
        lr_executor type ref to zcl_prc_executor_access,
          lr_exc type ref to cx_shm_attach_error,
          lv_time type t.

  &quot;... Clean up broken processes
  _garbage_collect( abap_true ).

  get time field lv_time.
  do.
    try.
        lr_area = zcl_prc_executor_area=&gt;attach_for_read( &apos;ZCL_PRC_EXECUTOR_AREA&apos; ).
        exit. &quot;... Exit Do
        catch cx_shm_exclusive_lock_active
              cx_shm_version_limit_exceeded
              cx_shm_change_lock_active
              cx_shm_read_lock_active
              cx_shm_no_active_version into lr_exc.
        get time.
        &quot;... 1hr Retry(pretty extreme)
        if ( ( sy-uzeit - lv_time ) mod 86400 ) gt 3600.
          raise exception type zcx_prc_wait_timout_exception.
        endif.
    endtry.
  enddo.

  &quot;... Check for previous success
  check lr_area is not initial and lr_area-&gt;root is not initial.
  lr_executor = lr_area-&gt;root.
  try.
    rv_complete = lr_executor-&gt;is_complete( iv_pid = iv_pid iv_guid = iv_guid ).
    catch zcx_prc_process_failed.
      lr_area-&gt;detach( ).
      raise exception type zcx_prc_process_failed.
  endtry.
  lr_area-&gt;detach( ).
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_PRC_LOCK" VERSION="1" LANGU="E" DESCRIPT="Lock object for the BP" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_PRC_LOCK" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <method CLSNAME="ZCL_PRC_LOCK" CMPNAME="DEQUEUE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_LOCK" CMPNAME="DEQUEUE" SCONAME="KEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <source>method dequeue.
    data: lv_key type zprcd_lock_tab-lock_key.
    lv_key = key.
    call function &apos;DEQUEUE_EZPRC_LOCK&apos;
      exporting
        lock_key = lv_key.
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_PRC_LOCK" CMPNAME="ENQUEUE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_PRC_LOCK" CMPNAME="ENQUEUE" SCONAME="KEY" VERSION="1" LANGU="E" DESCRIPT="Must be less than 150 chars" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_PRC_LOCK" CMPNAME="ENQUEUE" SCONAME="WAIT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_FALSE"/>
   <exception CLSNAME="ZCL_PRC_LOCK" CMPNAME="ENQUEUE" SCONAME="ZCX_PRC_LOCKED" VERSION="1" LANGU="E" DESCRIPT="Lock key is currently Locked" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_PRC_LOCK" CMPNAME="ENQUEUE" SCONAME="ZCX_PRC_SYSTEM_FAILURE" VERSION="1" LANGU="E" DESCRIPT="System Fail" MTDTYPE="0" EDITORDER="2 "/>
   <source>method enqueue.
    data: lv_key type zprcd_lock_tab-lock_key.
    lv_key = key.
    call function &apos;ENQUEUE_EZPRC_LOCK&apos;
      exporting
        lock_key       = lv_key
        _wait          = wait
        _scope         = &apos;1&apos;
      exceptions
        foreign_lock   = 1
        system_failure = 2
        others         = 3.

    case sy-subrc.
      when 1.
        raise exception type zcx_prc_locked.
      when 2 or 3.
        raise exception type zcx_prc_system_failure.
    endcase.
endmethod.</source>
  </method>
 </CLAS>
 <DTEL ROLLNAME="ZPRCE_DATA" DDLANGUAGE="E" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="08" SCRLEN2="15" SCRLEN3="15" DDTEXT="PRC Data" REPTEXT="Serialised Data" SCRTEXT_S="Ser Data" SCRTEXT_M="Serialised Data" SCRTEXT_L="Serialised Data" AUTHCLASS="00" DTELMASTER="E" DATATYPE="RSTR" LENG="000000" DECIMALS="000000" OUTPUTLEN="000000">
  <tpara/>
 </DTEL>
 <ENQU VIEWNAME="EZPRC_LOCK" AS4LOCAL="A" AS4VERS="0000" DDLANGUAGE="E" AGGTYPE="E" AUTHCLASS="00" ROOTTAB="ZPRCD_LOCK_TAB" DDTEXT="PRC Locking Object">
  <dd26e VIEWNAME="EZPRC_LOCK" TABNAME="ZPRCD_LOCK_TAB" TABPOS="0001" FORTABNAME="ZPRCD_LOCK_TAB" ENQMODE="X"/>
  <dd27p VIEWNAME="EZPRC_LOCK" OBJPOS="0001" DDLANGUAGE="E" VIEWFIELD="LOCK_KEY" TABNAME="ZPRCD_LOCK_TAB" FIELDNAME="LOCK_KEY" KEYFLAG="X" ENQMODE="X" DATATYPE="CHAR" FLENGTH="000150" INTTYPE="C" INTLEN="000300" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" OUTPUTLEN="000000" DECIMALS="000000" OUTPUTSTYLE="00" EXVFLENGTH="000000" EXVDECIMALS="000000"/>
  <ddena VIEWNAME="EZPRC_LOCK" TABNAME="ZPRCD_LOCK_TAB" FIELDNAME="LOCK_KEY" VIEWFIELD="LOCK_KEY"/>
 </ENQU>
 <FUGR AREA="ZPRCC_WP_CONFIG" SPRAS="E" AREAT="Extended Table Maintenance (Generated)">
  <functionGroupDocumentation/>
  <mainprogram NAME="SAPLZPRCC_WP_CONFIG" SQLX="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="421" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <dynpros>
    <dynpro PROG="SAPLZPRCC_WP_CONFIG" DNUM="0001" FNUM="0001" BZMX="61 " BZBR="69 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="61 " NOCO="83 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141112" TGEN="130655" DTEXT="View maint: Overview screen ZPRCC_WP_CONFIG">
     <dynprofield FNAM="TCTRL_ZPRCC_WP_CONFIG" DIDX="003B" FLG1="F8" FLG2="FC" FLG3="00" FILL="T" FMB1="00" FMB2="00" LENG="1F" LINE="01" COLN="02" LTYP="E" LANF="65" LBLK="01" LREP="01" AUTH="101" AGLT="00" ADEZ="00"/>
     <dynprofield FNAM="VIM_FRAME_FIELD" DIDX="003C" FLG1="80" FLG2="02" FLG3="88" FMB1="30" FMB2="40" LENG="3C" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________________________________________________"/>
     <dynprofield FNAM="*ZPRCC_WP_CONFIG-USER_NAME" DIDX="000C" FLG1="20" FLG2="00" FLG3="00" FMB1="30" FMB2="A0" LENG="28" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="3" AGLT="00" ADEZ="00" STXT="User Name" RES1="                                       00"/>
     <dynprofield FNAM="*ZPRCC_WP_CONFIG-MAX_WP" DIDX="000B" FLG1="00" FLG2="00" FLG3="08" FMB1="30" FMB2="80" LENG="28" LINE="01" COLN="02" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="+"/>
     <dynprofield FNAM="VIM_MARKED" DIDX="0001" FLG1="80" FLG2="00" FLG3="88" FILL="C" FMB1="00" FMB2="20" LENG="01" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00" STXT="_"/>
     <dynprofield FNAM="ZPRCC_WP_CONFIG-USER_NAME" DIDX="000C" FLG1="B0" FLG2="00" FLG3="80" FMB1="30" FMB2="20" LENG="0C" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" GRP1="KEY" ITYP="C" AGLT="18" ADEZ="00" STXT="____________" RES1="                                       00"/>
     <dynprofield FNAM="ZPRCC_WP_CONFIG-MAX_WP" DIDX="000B" FLG1="B0" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="0B" LINE="01" COLN="02" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="INT4" ITYP="X" AGLT="0A" ADEZ="00" STXT="___________" RES1="                                       00"/>
     <dynprofield FNAM="VIM_POSI_PUSH" DIDX="0014" FLG1="80" FLG2="00" FLG3="88" FILL="P" FMB1="30" FMB2="00" LENG="14" LINE="3D" COLN="14" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" AGLT="00" ADEZ="00" STXT="____________________" RES1="                                                                                                                                                                        POSI"/>
     <dynprofield FNAM="VIM_POSITION_INFO" DIDX="001E" FLG1="80" FLG2="02" FLG3="88" FMB1="33" FMB2="00" LENG="1E" LINE="3D" COLN="29" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="OK_CODE" DIDX="0014" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE LISTE_INITIALISIEREN.
 LOOP AT EXTRACT WITH CONTROL
  TCTRL_ZPRCC_WP_CONFIG CURSOR NEXTLINE.
   MODULE LISTE_SHOW_LISTE.
 ENDLOOP.
*
PROCESS AFTER INPUT.
 MODULE LISTE_EXIT_COMMAND AT EXIT-COMMAND.
 MODULE LISTE_BEFORE_LOOP.
 LOOP AT EXTRACT.
   MODULE LISTE_INIT_WORKAREA.
   CHAIN.
    FIELD ZPRCC_WP_CONFIG-USER_NAME .
    FIELD ZPRCC_WP_CONFIG-MAX_WP .
    MODULE SET_UPDATE_FLAG ON CHAIN-REQUEST.
   ENDCHAIN.
   FIELD VIM_MARKED MODULE LISTE_MARK_CHECKBOX.
   CHAIN.
    FIELD ZPRCC_WP_CONFIG-USER_NAME .
    MODULE LISTE_UPDATE_LISTE.
   ENDCHAIN.
 ENDLOOP.
 MODULE LISTE_AFTER_LOOP.</dynproflowsource>
    </dynpro>
   </dynpros>
   <source>* regenerated at 12.11.2014 13:06:55 by  HXA023
*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZPRCC_WP_CONFIGTOP.               &quot; Global Data
  INCLUDE LZPRCC_WP_CONFIGUXX.               &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZPRCC_WP_CONFIGF...               &quot; Subroutines
* INCLUDE LZPRCC_WP_CONFIGO...               &quot; PBO-Modules
* INCLUDE LZPRCC_WP_CONFIGI...               &quot; PAI-Modules
* INCLUDE LZPRCC_WP_CONFIGE...               &quot; Events
* INCLUDE LZPRCC_WP_CONFIGP...               &quot; Local class implement.
* INCLUDE LZPRCC_WP_CONFIGT99.               &quot; ABAP Unit tests
  INCLUDE LZPRCC_WP_CONFIGF00                     . &quot; subprograms
  INCLUDE LZPRCC_WP_CONFIGI00                     . &quot; PAI modules
  INCLUDE LSVIMFXX                                . &quot; subprograms
  INCLUDE LSVIMOXX                                . &quot; PBO modules
  INCLUDE LSVIMIXX                                . &quot; PAI modules</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZPRCC_WP_CONFIGF00" SQLX="X" EDTX="X" SUBC="I" LEVL="740" RLOAD="E">
    <include_source>*---------------------------------------------------------------------*
*    view related FORM routines
*   generation date: 12.11.2014 at 13:06:55 by user HXA023
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

* base table related FORM-routines.............
INCLUDE LSVIMFTX .</include_source>
   </include>
   <include NAME="LZPRCC_WP_CONFIGI00" SQLX="X" EDTX="X" SUBC="I" LEVL="740" RLOAD="E">
    <include_source>*---------------------------------------------------------------------*
*    view related PAI modules
*   generation date: 12.11.2014 at 13:06:55 by user HXA023
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

INCLUDE LSVIMITX . &quot;base table related PAI modules</include_source>
   </include>
   <include NAME="LZPRCC_WP_CONFIGTOP" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="421" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>* regenerated at 12.11.2014 13:06:55 by  HXA023
FUNCTION-POOL ZPRCC_WP_CONFIG            MESSAGE-ID SV.

* INCLUDE LZPRCC_WP_CONFIGD...               &quot; Local class definition
  INCLUDE LSVIMDAT                                . &quot;general data decl.
  INCLUDE LZPRCC_WP_CONFIGT00                     . &quot;view rel. data dcl.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="TABLEFRAME_ZPRCC_WP_CONFIG" STEXT="Extended Table Maintenance: Upper Level">
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 002"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 003"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 004"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 005"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tabelle mit dynam. zu deaktivierenden CUA-Funkt." INDEX=" 006"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 007"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 008"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 009"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEFRAME_ZPRCC_WP_CONFIG
*   generation date: 12.11.2014 at 13:06:54 by user HXA023
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEFRAME TABLES X_HEADER X_NAMTAB DBA_SELLIST DPL_SELLIST
                            EXCL_CUA_FUNCT
                     USING  CORR_NUMBER VIEW_ACTION VIEW_NAME.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="TABLEPROC_ZPRCC_WP_CONFIG" GLOBAL="X" STEXT="Lower-level extended table maintenance">
    <importing PARAMETER="FCODE" DEFAULT="&apos;RDED&apos;"/>
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <exporting PARAMETER="LAST_ACT_ENTRY"/>
    <exporting PARAMETER="UCOMM"/>
    <exporting PARAMETER="UPDATE_REQUIRED"/>
    <tables PARAMETER="CORR_KEYTAB" DBSTRUCT="E071K"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="EXTRACT"/>
    <tables PARAMETER="TOTAL"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <exceptions EXCEPTION="SAVING_CORRECTION_FAILED"/>
    <documentation PARAMETER="FCODE" KIND="P" STEXT="gewünschte Funktion des Bausteins" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 002"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 003"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 004"/>
    <documentation PARAMETER="LAST_ACT_ENTRY" KIND="P" STEXT="Index der Cursorposition in der Anzeigetabelle" INDEX=" 005"/>
    <documentation PARAMETER="UCOMM" KIND="P" STEXT="letztes User-command innerhalb der Viewpflege" INDEX=" 006"/>
    <documentation PARAMETER="UPDATE_REQUIRED" KIND="P" STEXT="Flag: Einträge verändert, Sichern erforderlich" INDEX=" 007"/>
    <documentation PARAMETER="CORR_KEYTAB" KIND="P" STEXT="Tabelle mit den Keys der zu transport. Einträge" INDEX=" 008"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 009"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 010"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tab. der nicht zu aktivierenden CUA-Funktionen" INDEX=" 011"/>
    <documentation PARAMETER="EXTRACT" KIND="P" STEXT="Tab. der gerade sichtbaren Daten (Anzeigetabelle" INDEX=" 012"/>
    <documentation PARAMETER="TOTAL" KIND="P" STEXT="Tabelle, mit allen von der DB gelesenen Daten" INDEX=" 013"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 014"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 015"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 016"/>
    <documentation PARAMETER="SAVING_CORRECTION_FAILED" KIND="X" STEXT="Fehler beim Sichern der Korrektureinträge" INDEX=" 017"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEPROC_ZPRCC_WP_CONFIG
*   generation date: 12.11.2014 at 13:06:55 by user HXA023
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEPROC.</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR AREA="ZPRC" SPRAS="E" AREAT="Function Group for Parallel Processing">
  <functionGroupDocumentation/>
  <mainprogram NAME="SAPLZPRC" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="110" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZPRCTOP.                          &quot; Global Data
  INCLUDE LZPRCUXX.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZPRCF...                          &quot; Subprograms
* INCLUDE LZPRCO...                          &quot; PBO-Modules
* INCLUDE LZPRCI...                          &quot; PAI-Modules</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZPRCTOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="110" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ZPRC.                         &quot;MESSAGE-ID ..</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_PRC_RUN_MANAGED_TASK" REMOTE="R" STEXT="Run a PRC Process">
    <importing PARAMETER="IV_PROCESS" TYP="ZPRCE_DATA"/>
    <importing PARAMETER="IV_DELAY" TYP="STRING"/>
    <exporting PARAMETER="EV_PROCESS" TYP="ZPRCE_DATA"/>
    <exceptions EXCEPTION="PRC_PROCESS_FAILED"/>
    <documentation PARAMETER="IV_PROCESS" KIND="P" STEXT="Process" INDEX=" 001"/>
    <documentation PARAMETER="IV_DELAY" KIND="P" INDEX=" 002"/>
    <documentation PARAMETER="EV_PROCESS" KIND="P" STEXT="PRC Data" INDEX=" 003"/>
    <documentation PARAMETER="PRC_PROCESS_FAILED" KIND="X" STEXT="The Process failed" INDEX=" 004"/>
    <fm_source_new>*======================================================================*
* These objects were created by me: Hugo Armstrong, 2012               *
* Don&apos;t try to claim credit for my work. Modifying the objects may     *
* cause the entire package to break so that is not exactly recommended *
*                                                                      *
* hugo.armstrong@gmail.com                                             *
*======================================================================*
  data: lr_process type ref to zcl_prc_managed_task,
        lv_pid type char8,
        lr_exc type ref to cx_root.

  &quot;... Deserialize the input object
  call transformation id_indent
     source xml iv_process
     result obj = lr_process.

  if iv_delay is not initial.
    wait up to iv_delay seconds.
  endif.

  &quot;... Get the process id
  lv_pid = lr_process-&gt;get_pid( ).

  &quot;... Attach current WP
  zcl_prc_monitor=&gt;attach_wp( lv_pid ).

  try.
      lr_process-&gt;mr_runnable-&gt;run( ).
    catch cx_root into lr_exc. &quot;... Catch all! Just need to make sure the deregister happens fail or not
      zcl_prc_monitor=&gt;deregister_pid( lv_pid ).

      &quot;... Re-raise the process failed exception. The original exception cannot
      &quot;... be raised from this RFC enable function but it is stored int the LR_EXC var
      raise prc_process_failed.
  endtry.

  zcl_prc_monitor=&gt;deregister_pid( lv_pid ).</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_PRC_RUN_FUTURE_TASK" REMOTE="R" STEXT="Run a PRC Process">
    <importing PARAMETER="IV_CALLABLE" TYP="ZPRCE_DATA"/>
    <importing PARAMETER="IV_DELAY" OPTIONAL="X" TYP="STRING"/>
    <exporting PARAMETER="EV_PROCESS" TYP="ZPRCE_DATA"/>
    <exceptions EXCEPTION="NON_SERIALIZABLE_RESULT"/>
    <exceptions EXCEPTION="NO_RETURN_TYPE_SET"/>
    <exceptions EXCEPTION="PRC_PROCESS_FAILED"/>
    <documentation PARAMETER="IV_CALLABLE" KIND="P" STEXT="Process" INDEX=" 001"/>
    <documentation PARAMETER="IV_DELAY" KIND="P" STEXT="Seconds, yes as a char e.g. &apos;2&apos; or &apos;0.2&apos; dont ask" INDEX=" 002"/>
    <documentation PARAMETER="EV_PROCESS" KIND="P" STEXT="PRC Data" INDEX=" 003"/>
    <documentation PARAMETER="NON_SERIALIZABLE_RESULT" KIND="X" STEXT="A Result object ref was used that cant be serialized" INDEX=" 004"/>
    <documentation PARAMETER="NO_RETURN_TYPE_SET" KIND="X" STEXT="No Return type was set for the Callable Interface" INDEX=" 005"/>
    <documentation PARAMETER="PRC_PROCESS_FAILED" KIND="X" STEXT="The Completion Process failed" INDEX=" 006"/>
    <fm_source_new>*======================================================================*
* These objects were created by me: Hugo Armstrong, 2012               *
* Don&apos;t try to claim credit for my work. Modifying the objects may     *
* cause the entire package to break so that is not exactly recommended *
*                                                                      *
* hugo.armstrong@gmail.com                                             *
*======================================================================*
  data: lr_callable type ref to zif_prc_callable,
        lr_data type ref to data,
        lv_pid type char8,
        lr_exc type ref to cx_root.
  field-symbols: &lt;fs_any&gt; type any.

  &quot;... Deserialize the input object
  call transformation id_indent
     source xml iv_callable
     result obj = lr_callable.

  if iv_delay is not initial.
    wait up to iv_delay seconds.
  endif.

  &quot;... Attach current WP
  zcl_prc_future_executor=&gt;attach_wp( lr_callable-&gt;mv_cpid ).

  try.
      &quot;... Consume the callable
      lr_data = lr_callable-&gt;call( ).
      assign lr_data-&gt;* to &lt;fs_any&gt;.

      &quot;... Set the result
      zcl_prc_future_executor=&gt;set_result( iv_pid = lr_callable-&gt;mv_cpid
                                           iv_guid = lr_callable-&gt;mv_guid
                                           iv_wpid = lr_callable-&gt;mv_wpid
                                           ir_result = &lt;fs_any&gt; ).
    catch zcx_prc_non_serializable.
      zcl_prc_future_executor=&gt;deregister_pid( lr_callable-&gt;mv_cpid ).
      raise non_serializable_result.
    catch cx_root into lr_exc. &quot;... Catch all! Just need to make sure the deregister happens fail or not
      &quot;... Raise a final exception so it can be picked up
      zcl_prc_future_executor=&gt;deregister_pid( lr_callable-&gt;mv_cpid ).

      &quot;... Re-raise the process failed exception. The original exception cannot
      &quot;... be raised from this RFC enable function but it is stored int the LR_EXC var
      raise prc_process_failed.
  endtry.</fm_source_new>
    <functionModuleDocumentation/>
   </functionmodule>
   <functionmodule NAME="Z_PRC_RUN_ISOLATED_TASK" REMOTE="R" STEXT="Run a PRC Background Process">
    <importing PARAMETER="IV_PROCESS" TYP="ZPRCE_DATA"/>
    <importing PARAMETER="IV_DELAY" OPTIONAL="X" TYP="STRING"/>
    <exceptions EXCEPTION="PRC_PROCESS_FAILED"/>
    <documentation PARAMETER="IV_PROCESS" KIND="P" STEXT="PRC Data" INDEX=" 001"/>
    <documentation PARAMETER="IV_DELAY" KIND="P" INDEX=" 002"/>
    <documentation PARAMETER="PRC_PROCESS_FAILED" KIND="X" STEXT="The Process failed" INDEX=" 003"/>
    <fm_source>*======================================================================*
* These objects were created by me: Hugo Armstrong, 2012               *
* Don&apos;t try to claim credit for my work. Modifying the objects may     *
* cause the entire package to break so that is not exactly recommended *
*                                                                      *
* hugo.armstrong@gmail.com                                             *
*======================================================================*
  data: lr_process type ref to zcl_prc_isolated_task.

  &quot;... Deserialize the input object
  call transformation id_indent
     source xml iv_process
     result obj = lr_process.

  if iv_delay is not initial.
    wait up to iv_delay seconds.
  endif.

  &quot;... Exceptions appropriately explode out
  lr_process-&gt;mr_runnable-&gt;run( ).</fm_source>
    <functionModuleDocumentation/>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <INTF CLSNAME="ZIF_PRC_RUNNABLE" VERSION="1" LANGU="E" DESCRIPT="Runnable Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <include CLSNAME="ZIF_PRC_RUNNABLE" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" STATE="1"/>
  <method CLSNAME="ZIF_PRC_RUNNABLE" CMPNAME="RUN" VERSION="1" LANGU="E" DESCRIPT="Run the process" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0"/>
 </INTF>
 <INTF CLSNAME="ZIF_COLLECTION" VERSION="1" LANGU="E" DESCRIPT="WAM Collection Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_COLLECTION" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <method CLSNAME="ZIF_COLLECTION" CMPNAME="GET_ITEM" VERSION="1" LANGU="E" DESCRIPT="Get the item at index" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_COLLECTION" CMPNAME="GET_ITEM" SCONAME="IV_INDEX" VERSION="1" LANGU="E" DESCRIPT="Index of the item" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZIF_COLLECTION" CMPNAME="GET_ITEM" SCONAME="RR_OBJECT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_COLLECTION" CMPNAME="GET_ITERATOR" VERSION="1" LANGU="E" DESCRIPT="Get an iterator" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_COLLECTION" CMPNAME="GET_ITERATOR" SCONAME="RIF_ITERATOR" VERSION="1" LANGU="E" DESCRIPT="Collection iterator" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_ITERATOR"/>
  </method>
  <method CLSNAME="ZIF_COLLECTION" CMPNAME="IS_EMPTY" VERSION="1" LANGU="E" DESCRIPT="Check if the collection is empty" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_COLLECTION" CMPNAME="IS_EMPTY" SCONAME="RV_EMPTY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_COLLECTION" CMPNAME="SIZE" VERSION="1" LANGU="E" DESCRIPT="Get the size of the collection (number of items)" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_COLLECTION" CMPNAME="SIZE" SCONAME="RV_SIZE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_ITERATOR" VERSION="1" LANGU="E" DESCRIPT="WAM Collection iterator" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <typeUsage CLSNAME="ZIF_ITERATOR" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <method CLSNAME="ZIF_ITERATOR" CMPNAME="CURRENT" VERSION="1" LANGU="E" DESCRIPT="Get the current item" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_ITERATOR" CMPNAME="CURRENT" SCONAME="RR_OBJECT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_ITERATOR" CMPNAME="FIRST" VERSION="1" LANGU="E" DESCRIPT="Get the first item" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_ITERATOR" CMPNAME="FIRST" SCONAME="RR_OBJECT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_ITERATOR" CMPNAME="GET_INDEX" VERSION="1" LANGU="E" DESCRIPT="Get the current Index in the collection" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_ITERATOR" CMPNAME="GET_INDEX" SCONAME="RV_INDEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
  </method>
  <method CLSNAME="ZIF_ITERATOR" CMPNAME="HAS_NEXT" VERSION="1" LANGU="E" DESCRIPT="Check if there is a next item" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_ITERATOR" CMPNAME="HAS_NEXT" SCONAME="RV_HASNEXT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
  </method>
  <method CLSNAME="ZIF_ITERATOR" CMPNAME="LAST" VERSION="1" LANGU="E" DESCRIPT="Get the last item" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_ITERATOR" CMPNAME="LAST" SCONAME="RR_OBJECT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
  <method CLSNAME="ZIF_ITERATOR" CMPNAME="NEXT" VERSION="1" LANGU="E" DESCRIPT="Get the next item" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_ITERATOR" CMPNAME="NEXT" SCONAME="RR_OBJECT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="OBJECT"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_PRC_CALLABLE" VERSION="1" LANGU="E" DESCRIPT="Callback interface for definition of callback" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <include CLSNAME="ZIF_PRC_CALLABLE" REFCLSNAME="IF_SERIALIZABLE_OBJECT" VERSION="1" STATE="1"/>
  <typeUsage CLSNAME="ZIF_PRC_CALLABLE" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <attribute CLSNAME="ZIF_PRC_CALLABLE" CMPNAME="MV_CPID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR8" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_PRC_CALLABLE" CMPNAME="MV_GUID" VERSION="1" LANGU="E" DESCRIPT="GUID For result retrieve later" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SYSUUID_X16" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_PRC_CALLABLE" CMPNAME="MV_WPID" VERSION="1" LANGU="E" DESCRIPT="Character field, 8 characters long" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR8" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZIF_PRC_CALLABLE" CMPNAME="CALL" VERSION="1" LANGU="E" DESCRIPT="Return a data ref to the result that will be exported" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_PRC_CALLABLE" CMPNAME="CALL" SCONAME="RV_RESULT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
  </method>
 </INTF>
 <PROG NAME="Z_PRC_BACKGROUND_JOB" VARCL="X" SUBC="1" RMAND="421" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="PRC Report to process Background Jobs" LENGTH="37 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_PRC_BACKGROUND_PROCESS
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

report z_prc_background_job.

parameters: guid type sysuuid_x16, delay type string.

data: ls_bg type zprcd_background.

select single * from zprcd_background into ls_bg where guid = guid.

if sy-subrc ne 0.
  &quot;... Jobs can NOT be re-run. They are ran once only
  &quot;... re-runnable scheduled jobs should be created as normal
  &quot;... that is not the purpose of this code
  raise exception type zcx_prc_process_failed.
else.
  &quot;... We have our item to process now, its on!
  delete zprcd_background from ls_bg.
  commit work.
endif.

data: lr_process type ref to zcl_prc_background_job.

&quot;... Deserialize the input object
call transformation id_indent
   source xml ls_bg-data
   result obj = lr_process.

if delay is not initial.
  wait up to delay seconds.
endif.

&quot;... Exceptions appropriately explode out
lr_process-&gt;mr_runnable-&gt;run( ).</source>
 </PROG>
 <PROG NAME="Z_PRC_BG_BATCH_JOB" VARCL="X" SUBC="1" RMAND="421" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="PRC Report to process Background Jobs" LENGTH="37 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_PRC_BACKGROUND_PROCESS
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

report z_prc_bg_batch_job.

data: ls_bg type zprcd_bg_batch.

get time stamp field data(lv_now).


do.
  select single * from zprcd_bg_batch into ls_bg where start_time lt lv_now.
  if sy-subrc ne 0.
    exit.
  endif.
  delete zprcd_bg_batch from ls_bg.
  commit work and wait.


  data: lr_process type ref to zcl_prc_bg_batch_job.

  &quot;... Deserialize the input object
  call transformation id_indent
     source xml ls_bg-data
     result obj = lr_process.

  new zcl_prc_isolated_task( ir_runnable = lr_process-&gt;mr_runnable )-&gt;start(  ).
*  try.
*    &quot;... Exceptions appropriately explode out
*    lr_process-&gt;mr_runnable-&gt;run( ).
*  endtry.

enddo.</source>
 </PROG>
 <TABL TABNAME="ZPRCD_COMPLETED" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Completed Process Table" AUTHCLASS="00" CONTFLAG="A" PROZPUFF="000" EXCLASS="4">
  <dd09l TABNAME="ZPRCD_COMPLETED" AS4LOCAL="A" AS4VERS="0000" TABKAT="2" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N"/>
  <dd03p TABNAME="ZPRCD_COMPLETED" FIELDNAME="CLIENT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" DEFFDNAME="CLIENT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_COMPLETED" FIELDNAME="GUID" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="SYSUUID_X16" ADMINFIELD="0" INTTYPE="X" INTLEN="000016" NOTNULL="X" DOMNAME="SYSUUID_X16" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="04" SCRLEN2="04" SCRLEN3="04" DTELMASTER="D" DATATYPE="RAW" LENG="000016" OUTPUTLEN="000032" DECIMALS="000000" MASK="  RAW E" MASKLEN="0000" DDTEXT="16 Byte UUID in 16 Bytes (Raw Format)" REPTEXT="UUID" SCRTEXT_S="UUID" SCRTEXT_M="UUID" SCRTEXT_L="UUID" DOMNAME3L="SYSUUID_X16" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_COMPLETED" FIELDNAME="DATA" DDLANGUAGE="E" POSITION="0003" ROLLNAME="ZPRCE_DATA" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="08" SCRLEN2="15" SCRLEN3="15" DTELMASTER="E" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTRE" MASKLEN="0000" DDTEXT="PRC Data" REPTEXT="Serialised Data" SCRTEXT_S="Ser Data" SCRTEXT_M="Serialised Data" SCRTEXT_L="Serialised Data" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_COMPLETED" FIELDNAME="TIME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TIMESTAMPL" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" DOMNAME="TZNTSTMPL" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000021" OUTPUTLEN="000027" DECIMALS="000007" MASK="  DEC E" MASKLEN="0000" DDTEXT="UTC Time Stamp in Long Form (YYYYMMDDhhmmssmmmuuun)" REPTEXT="Time Stamp" SCRTEXT_S="Time Stamp" SCRTEXT_M="Time Stamp" SCRTEXT_L="Time Stamp" DOMMASTER="D" DOMNAME3L="TZNTSTMPL" DEPTH="00" COMPTYPE="E" DEFFDNAME="TIMESTAMP" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_COMPLETED" FIELDNAME="WPID" DDLANGUAGE="E" POSITION="0005" ROLLNAME="CHAR8" ADMINFIELD="0" INTTYPE="C" INTLEN="000016" DOMNAME="CHAR8" ROUTPUTLEN="000000" HEADLEN="05" SCRLEN1="05" SCRLEN2="05" SCRLEN3="05" DTELMASTER="D" DATATYPE="CHAR" LENG="000008" OUTPUTLEN="000008" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="Character field, 8 characters long" REPTEXT="char8" SCRTEXT_S="char8" SCRTEXT_M="char8" SCRTEXT_L="char8" DOMNAME3L="CHAR8" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZPRCC_WP_CONFIG" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Contains config settings for User -&gt; WP Count" AUTHCLASS="00" MAINFLAG="X" CONTFLAG="C" PROZPUFF="000" EXCLASS="1">
  <dd09l TABNAME="ZPRCC_WP_CONFIG" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL2" PUFFERUNG="X" SCHFELDANZ="000" BUFALLOW="X"/>
  <dd03p TABNAME="ZPRCC_WP_CONFIG" FIELDNAME="USER_NAME" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="SYST_UNAME" ADMINFIELD="0" INTTYPE="C" INTLEN="000024" NOTNULL="X" DOMNAME="SYCHAR12" ROUTPUTLEN="000000" HEADLEN="12" SCRLEN1="10" SCRLEN2="18" SCRLEN3="18" DTELMASTER="D" DATATYPE="CHAR" LENG="000012" OUTPUTLEN="000012" DECIMALS="000000" MASK="  CHARE" MASKLEN="0000" DDTEXT="ABAP System Field: Name of Current User" REPTEXT="User" SCRTEXT_S="User" SCRTEXT_M="User Name" SCRTEXT_L="User Name" DOMNAME3L="SYCHAR12" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCC_WP_CONFIG" FIELDNAME="MAX_WP" DDLANGUAGE="E" POSITION="0002" ADMINFIELD="0" INTTYPE="X" INTLEN="000004" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="INT4" LENG="000010" OUTPUTLEN="000000" DECIMALS="000000" MASK="  INT4" MASKLEN="0000" DDTEXT="Max Work Processes" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZPRCD_BG_BATCH" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Background process to be executed as a batch" AUTHCLASS="00" CONTFLAG="A" PROZPUFF="000" EXCLASS="0">
  <dd09l TABNAME="ZPRCD_BG_BATCH" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N"/>
  <dd03p TABNAME="ZPRCD_BG_BATCH" FIELDNAME="CLIENT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" DEFFDNAME="CLIENT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BG_BATCH" FIELDNAME="GUID" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="SYSUUID_X16" ADMINFIELD="0" INTTYPE="X" INTLEN="000016" NOTNULL="X" DOMNAME="SYSUUID_X16" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="04" SCRLEN2="04" SCRLEN3="04" DTELMASTER="D" DATATYPE="RAW" LENG="000016" OUTPUTLEN="000032" DECIMALS="000000" MASK="  RAW E" MASKLEN="0000" DDTEXT="16 Byte UUID in 16 Bytes (Raw Format)" REPTEXT="UUID" SCRTEXT_S="UUID" SCRTEXT_M="UUID" SCRTEXT_L="UUID" DOMNAME3L="SYSUUID_X16" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BG_BATCH" FIELDNAME="DATA" DDLANGUAGE="E" POSITION="0003" ROLLNAME="ZPRCE_DATA" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="08" SCRLEN2="15" SCRLEN3="15" DTELMASTER="E" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTRE" MASKLEN="0000" DDTEXT="PRC Data" REPTEXT="Serialised Data" SCRTEXT_S="Ser Data" SCRTEXT_M="Serialised Data" SCRTEXT_L="Serialised Data" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BG_BATCH" FIELDNAME="TIME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TIMESTAMPL" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" DOMNAME="TZNTSTMPL" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000021" OUTPUTLEN="000027" DECIMALS="000007" MASK="  DEC E" MASKLEN="0000" DDTEXT="UTC Time Stamp in Long Form (YYYYMMDDhhmmssmmmuuun)" REPTEXT="Time Stamp" SCRTEXT_S="Time Stamp" SCRTEXT_M="Time Stamp" SCRTEXT_L="Time Stamp" DOMMASTER="D" DOMNAME3L="TZNTSTMPL" DEPTH="00" COMPTYPE="E" DEFFDNAME="TIMESTAMP" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BG_BATCH" FIELDNAME="START_TIME" DDLANGUAGE="E" POSITION="0005" ROLLNAME="TIMESTAMPL" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" DOMNAME="TZNTSTMPL" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000021" OUTPUTLEN="000027" DECIMALS="000007" MASK="  DEC E" MASKLEN="0000" DDTEXT="UTC Time Stamp in Long Form (YYYYMMDDhhmmssmmmuuun)" REPTEXT="Time Stamp" SCRTEXT_S="Time Stamp" SCRTEXT_M="Time Stamp" SCRTEXT_L="Time Stamp" DOMMASTER="D" DOMNAME3L="TZNTSTMPL" DEPTH="00" COMPTYPE="E" DEFFDNAME="TIMESTAMP" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZPRCD_LOCK_TAB" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Locking table for generic data" AUTHCLASS="00" MAINFLAG="N" CONTFLAG="L" PROZPUFF="000" EXCLASS="0">
  <dd09l TABNAME="ZPRCD_LOCK_TAB" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N"/>
  <dd03p TABNAME="ZPRCD_LOCK_TAB" FIELDNAME="LOCK_KEY" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ADMINFIELD="0" INTTYPE="C" INTLEN="000300" NOTNULL="X" ROUTPUTLEN="000000" HEADLEN="00" SCRLEN1="00" SCRLEN2="00" SCRLEN3="00" DATATYPE="CHAR" LENG="000150" OUTPUTLEN="000000" DECIMALS="000000" MASK="  CHAR" MASKLEN="0000" DEPTH="00" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TABL TABNAME="ZPRCD_BACKGROUND" DDLANGUAGE="E" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" CLIDEP="X" DDTEXT="Completed Process Table" AUTHCLASS="00" CONTFLAG="A" PROZPUFF="000" EXCLASS="0">
  <dd09l TABNAME="ZPRCD_BACKGROUND" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" SCHFELDANZ="000" BUFALLOW="N"/>
  <dd03p TABNAME="ZPRCD_BACKGROUND" FIELDNAME="CLIENT" DDLANGUAGE="E" POSITION="0001" KEYFLAG="X" ROLLNAME="MANDT" ADMINFIELD="0" INTTYPE="C" INTLEN="000006" NOTNULL="X" DOMNAME="MANDT" ROUTPUTLEN="000000" HEADLEN="03" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CLNT" LENG="000003" OUTPUTLEN="000003" DECIMALS="000000" ENTITYTAB="T000" MASK="  CLNTE" MASKLEN="0000" DDTEXT="Client" REPTEXT="Cl." SCRTEXT_S="Client" SCRTEXT_M="Client" SCRTEXT_L="Client" DOMNAME3L="MANDT" DEPTH="00" COMPTYPE="E" DEFFDNAME="CLIENT" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BACKGROUND" FIELDNAME="GUID" DDLANGUAGE="E" POSITION="0002" KEYFLAG="X" ROLLNAME="SYSUUID_X16" ADMINFIELD="0" INTTYPE="X" INTLEN="000016" NOTNULL="X" DOMNAME="SYSUUID_X16" ROUTPUTLEN="000000" HEADLEN="04" SCRLEN1="04" SCRLEN2="04" SCRLEN3="04" DTELMASTER="D" DATATYPE="RAW" LENG="000016" OUTPUTLEN="000032" DECIMALS="000000" MASK="  RAW E" MASKLEN="0000" DDTEXT="16 Byte UUID in 16 Bytes (Raw Format)" REPTEXT="UUID" SCRTEXT_S="UUID" SCRTEXT_M="UUID" SCRTEXT_L="UUID" DOMNAME3L="SYSUUID_X16" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BACKGROUND" FIELDNAME="DATA" DDLANGUAGE="E" POSITION="0003" ROLLNAME="ZPRCE_DATA" ADMINFIELD="0" INTTYPE="y" INTLEN="000008" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="08" SCRLEN2="15" SCRLEN3="15" DTELMASTER="E" DATATYPE="RSTR" LENG="000000" OUTPUTLEN="000000" DECIMALS="000000" MASK="  RSTRE" MASKLEN="0000" DDTEXT="PRC Data" REPTEXT="Serialised Data" SCRTEXT_S="Ser Data" SCRTEXT_M="Serialised Data" SCRTEXT_L="Serialised Data" DEPTH="00" COMPTYPE="E" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
  <dd03p TABNAME="ZPRCD_BACKGROUND" FIELDNAME="TIME" DDLANGUAGE="E" POSITION="0004" ROLLNAME="TIMESTAMPL" ADMINFIELD="0" INTTYPE="P" INTLEN="000011" DOMNAME="TZNTSTMPL" ROUTPUTLEN="000000" HEADLEN="19" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="DEC" LENG="000021" OUTPUTLEN="000027" DECIMALS="000007" MASK="  DEC E" MASKLEN="0000" DDTEXT="UTC Time Stamp in Long Form (YYYYMMDDhhmmssmmmuuun)" REPTEXT="Time Stamp" SCRTEXT_S="Time Stamp" SCRTEXT_M="Time Stamp" SCRTEXT_L="Time Stamp" DOMMASTER="D" DOMNAME3L="TZNTSTMPL" DEPTH="00" COMPTYPE="E" DEFFDNAME="TIMESTAMP" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
</nugget>
